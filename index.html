<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>階層式心智圖生成器 - Pro (視覺化節點 + AI分析)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js for PDF processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <!-- Mammoth.js for DOCX processing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <!-- jsPDF and html2canvas for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- D3.js for Mind Map Visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --accent: #0ea5e9;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --light-bg: #f8fafc;
            --dark-bg: #0f172a;
            --text-primary: #1e293b;
            --text-secondary: #475569;

            /* 定義層級顏色變數 */
            --color-level-0: #6366f1; /* 主題 */
            --color-level-1: #8b5cf6; /* 大綱 */
            --color-level-2: #0ea5e9; /* 章節 */
            --color-level-3: #10b981; /* 重點 */
            --color-level-4: #f59e0b; /* 額外層級 */
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f0f2f5, #e6e9ef);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
            padding-top: 50px; /* Add padding to make space for the banner */
            position: relative; /* For positioning the banner */
        }
        
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            width: 100%;
            max-width: 1200px;
            display: flex;
            flex-direction: column;
            gap: 2.5rem;
            transition: all 0.3s ease;
        }
        
        .input-section, .output-section, .summary-section, .description-section {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        textarea {
            min-height: 150px;
            resize: vertical;
            border-radius: 0.75rem;
            padding: 1.25rem;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            background-color: var(--light-bg);
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        .btn {
            padding: 0.75rem 1.75rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: none;
            font-size: 0.95rem;
            gap: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }

        .btn-sm {
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 0.5rem;
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(99, 102, 241, 0.3);
        }
        
        .btn-secondary {
            background-color: #e2e8f0;
            color: #475569;
        }
        
        .btn-secondary:hover {
            background-color: #cbd5e1;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(203, 213, 225, 0.3);
        }
        
        .btn-accent {
            background-color: var(--accent);
            color: white;
        }
        
        .btn-accent:hover {
            background-color: #0284c7;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(14, 165, 233, 0.3);
        }
        
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #dc2626;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(239, 68, 68, 0.3);
        }
        
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .mind-map-container, .summary-content {
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            min-height: 200px;
            background-color: var(--light-bg);
            color: var(--text-secondary);
            overflow: auto; 
            line-height: 1.6;
            transition: all 0.3s ease;
        }
        
        .mind-map-container:hover, .summary-content:hover {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
        }

        /* D3 心智圖樣式 */
        .mind-map-container {
            min-height: 400px;
            max-height: 85vh; /* Adjusted max-height for more space */
            padding: 0; /* Ensures inner content starts at edge */
            overflow: auto; /* Ensure this container scrolls */
            box-sizing: border-box; /* Added box-sizing */
        }
        .node circle {
            stroke-width: 2.5px;
            cursor: pointer;
        }
        .node text {
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        .link {
            fill: none;
            stroke: #cbd5e1;
            stroke-width: 2px;
        }
        
        .error-message {
            color: var(--danger);
            font-weight: 500;
            margin-top: 1rem;
            text-align: center;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: #fef2f2;
        }
        
        .file-input-label {
            display: block;
            padding: 0.75rem 1.5rem;
            background-color: var(--accent);
            color: white;
            border-radius: 0.75rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(14, 165, 233, 0.2);
        }
        
        .file-input-label:hover {
            background-color: #0284c7;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(59, 130, 246, 0.3);
        }
        
        #imageInput, #docInput {
            display: none;
        }
        
        #imagePreview {
            max-width: 100%;
            height: auto;
            border-radius: 0.75rem;
            margin-top: 1rem;
            border: 1px solid #e2e8f0;
            max-height: 300px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        
        .api-key-section {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
            padding: 1.75rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            background: linear-gradient(to bottom, #f8fafc, #f1f5f9);
            box-shadow: 0 4px 10px rgba(0,0,0,0.03);
        }
        
        .api-key-section input[type="password"] {
            padding: 0.9rem;
            border-radius: 0.75rem;
            border: 1px solid #cbd5e1;
            width: 100%;
            font-size: 0.95rem;
            background-color: white;
            transition: all 0.3s ease;
        }
        
        .api-key-section input[type="password"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }
        
        .file-upload-section {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .file-upload-card {
            flex: 1;
            min-width: 220px;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.75rem;
            text-align: center;
            background: white;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        
        .file-upload-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.08);
            border-color: var(--primary);
        }
        
        .file-upload-card h3 {
            font-size: 1.15rem;
            color: var(--text-primary);
            margin-bottom: 1.25rem;
            font-weight: 600;
        }
        
        .file-format-icons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 1.25rem;
        }
        
        .file-icon {
            width: 45px;
            height: 55px;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: bold;
            position: relative;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .file-icon::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 5px;
            width: 35px;
            height: 5px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
        }
        
        .file-icon.pdf { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .file-icon.docx { background: linear-gradient(135deg, #2563eb, #1d4ed8); }
        .file-icon.txt { background: linear-gradient(135deg, #10b981, #059669); }
        .file-icon.image { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }
        
        .doc-preview {
            margin-top: 1rem;
            padding: 1.25rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            background: white;
            max-height: 250px;
            overflow-y: auto;
            font-size: 0.9rem;
            line-height: 1.6;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0,0,0,0.03);
        }
        
        .doc-preview p {
            margin: 0.75rem 0;
        }
        
        .file-info {
            font-size: 0.85rem;
            color: #64748b;
            margin-top: 0.75rem;
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .file-info span {
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            background-color: #f1f5f9;
        }
        
        .progress-bar {
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            margin-top: 1.25rem;
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }
        
        .progress {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 1.25rem;
        }
        
        .tab {
            padding: 0.9rem 1.75rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-weight: 500;
            color: var(--text-secondary);
            position: relative;
        }
        
        .tab.active {
            color: var(--primary);
            font-weight: 600;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -3px;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary);
            border-radius: 3px 3px 0 0;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .section-header-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .section-header h2 {
            font-size: 1.35rem;
            color: var(--text-primary);
            font-weight: 600;
        }
        
        .section-icon {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }
        
        .action-buttons .btn {
            flex: 1;
            min-width: 200px;
        }
        
        /* 摘要內容的層級樣式 */
        .summary-level-0 { font-size: 1.2rem; font-weight: bold; color: #6366f1; margin: 0; }
        .summary-level-1 { font-size: 1.1rem; font-weight: 600; color: #8b5cf6; margin: 0 0 0 1rem; }
        .summary-level-2 { font-size: 1.05rem; font-weight: 500; color: #0ea5e9; margin: 0 0 0 2rem; }
        .summary-level-3 { font-size: 1rem; color: #10b981; margin: 0 0 0 3rem; }
        .summary-level-4 { font-size: 0.95rem; color: #f59e0b; margin: 0 0 0 4rem; }
        
        /* 內容描述區塊樣式 */
        #descriptionOutput h4 {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary);
            margin-top: 1.25rem;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #e2e8f0;
        }
        #descriptionOutput p, #descriptionOutput ul {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }
        #descriptionOutput ul {
            list-style-type: disc;
            padding-left: 1.5rem;
        }
        #descriptionOutput li {
            margin-bottom: 0.5rem;
        }
        #descriptionOutput a {
            color: var(--accent);
            text-decoration: underline;
            word-break: break-all;
        }
        #descriptionOutput a:hover {
            color: var(--primary-dark);
        }

        @media (max-width: 768px) {
            .container {
                padding: 1.5rem;
            }
            
            .file-upload-section {
                flex-direction: column;
            }
            
            .action-buttons .btn {
                min-width: 100%;
            }
        }
        
        .floating-info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            z-index: 100;
            max-width: 300px;
            animation: floatUp 0.5s ease;
            border: 1px solid #e2e8f0;
        }
        
        @keyframes floatUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .floating-info h3 {
            margin-top: 0;
            color: var(--primary);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--text-secondary);
        }
        
        .level-indicator {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }
        
        .level-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.8rem;
            background: #f1f5f9;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
        }
        
        .level-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .btn-download {
            background-color: #f1f5f9;
            color: #475569;
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }
        .btn-download:hover {
            background-color: #e2e8f0;
        }

        /* Modal specific styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            padding: 2rem;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            position: relative;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 2rem;
            cursor: pointer;
            color: #64748b;
            line-height: 1;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .modal-close-btn:hover {
            background-color: #f1f5f9;
            color: #1e293b;
        }

        .modal-body {
            overflow-y: auto;
        }

        .modal-content h2 {
            font-size: 1.75rem;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #e2e8f0;
        }

        .modal-content h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
        }

        .modal-content h4 {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent);
            margin-top: 1rem;
            margin-bottom: 0.75rem;
        }

        .modal-content ul, .modal-content ol {
            list-style-position: inside;
            margin-left: 1.5rem;
            margin-bottom: 1rem;
            color: var(--text-secondary);
        }

        .modal-content ul li, .modal-content ol li {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        .modal-content strong {
            color: var(--text-primary);
        }

        .modal-content a {
            color: var(--primary);
            text-decoration: underline;
        }

        .modal-content p {
            margin-bottom: 1rem;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .modal-content code {
            background-color: #e2e8f0;
            padding: 0.2em 0.4em;
            border-radius: 0.3em;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            font-size: 0.875em;
        }

        /* Styles for no-line display */
        .mindmap-no-line-root {
            padding: 1rem; /* Keep padding for inner content spacing */
            background-color: #ffffff; /* Use white background for the container */
            border-radius: 1rem;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            width: 100%; /* Ensure it takes full width */
            box-sizing: border-box; /* Include padding in width calculation */
            max-height: none; /* Crucial: Allow it to expand fully and push parent scroll */
            overflow: visible; /* Crucial: Allow content to flow and trigger parent scroll */
        }
        .node-item-wrapper {
            display: block;
            margin-bottom: 0.75rem; /* Increased spacing */
        }
        .node-content-display {
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s ease, box-shadow 0.2s ease;
            align-items: center;
            display: flex;
            position: relative;
            box-shadow: 0 2px 5px rgba(0,0,0,0.08); /* Node shadow */
            color: var(--text-primary); /* Default text color */
            cursor: pointer; /* Make the whole node clickable */
            min-height: 40px; /* Ensure consistent height */
        }
        .node-content-display:hover {
            filter: brightness(1.03); /* Slightly brighter on hover */
            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
        }

        /* Horizontal line element */
        .horizontal-line {
            display: block;
            width: 20px; /* Length of the horizontal line */
            height: 2px;
            background-color: var(--primary); /* Line color */
            margin-right: 8px; /* Space between line and text */
            border-radius: 1px;
            flex-shrink: 0; /* Prevent line from shrinking */
        }

        .node-text {
            flex-grow: 1; /* Allow text to take available space */
            line-height: 1.3; /* Adjust line height for better text display */
        }
        .expand-toggle {
            cursor: pointer;
            font-size: 1.2em;
            padding-right: 0.5rem; /* Padding after arrow */
            transition: transform 0.2s ease-in-out;
            color: var(--primary); /* Arrow color */
            flex-shrink: 0; /* Prevent toggle from shrinking */
        }

        .children-container {
            padding-left: 1.5rem; /* Indent children more */
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease-out;
        }
        .children-container.collapsed {
            max-height: 0 !important;
            overflow: hidden !important;
        }
        .children-container.expanded { /* New class for expanded state */
            max-height: none !important; /* Allow it to expand fully */
            overflow: visible !important; /* Ensure content flows */
        }

        /* AI分析問答Modal的專屬樣式 */
        #qaChatHistory {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .qa-bubble {
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            max-width: 85%;
            line-height: 1.5;
            word-wrap: break-word;
        }
        .qa-bubble.user {
            background-color: #e0e7ff;
            color: #3730a3;
            align-self: flex-end;
            text-align: right;
        }
        .qa-bubble.ai {
            background-color: #f1f5f9;
            color: #334155;
            align-self: flex-start;
            text-align: left;
        }
        .external-info-box {
            background-color: #f0f9ff;
            border-left: 4px solid #0ea5e9;
            padding: 10px;
            margin-top: 15px;
            border-radius: 0 0.5rem 0.5rem 0;
        }
        .external-info-box strong {
            color: #0c4a6e;
        }
        .external-info-box p {
            margin-top: 5px;
            margin-bottom: 0;
        }
        .external-info-box .source {
            font-size: 0.8em;
            color: #64748b;
            margin-top: 10px;
        }
        .external-info-box .source a {
            color: #0ea5e9;
            text-decoration: underline;
        }

        /* ===== NEW: Collapsible Section Styles (MODIFIED) ===== */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 0.5rem 0; /* Add some padding for easier clicking */
        }
        .toggle-icon {
            transition: transform 0.3s ease-out;
            width: 24px;
            height: 24px;
            color: var(--text-secondary);
        }
        .collapsible-content {
            max-height: 3000px; /* A large enough value for any content */
            overflow: auto; /* MODIFIED: Ensure content scrolls if it overflows */
            transition: max-height 0.5s ease-in-out;
        }
        .collapsible-content.collapsed {
            max-height: 0;
        }
        .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }
        /* ===== END: Collapsible Section Styles ===== */

        /* Author banner styles */
        .author-banner {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #333;
            color: white;
            text-align: center;
            padding: 8px 0;
            font-size: 0.9rem;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

    </style>
</head>
<body class="bg-gray-100 p-4 md:p-8">
    <!-- Author Banner -->
    <div class="author-banner">作者:Ping 2025/07/09</div>

    <!-- Operation Instructions Modal -->
    <div id="instructionModal" class="modal-overlay">
        <div class="modal-content">
            <button id="closeModalBtn" class="modal-close-btn">&times;</button>
            <h2>操作說明</h2>
            <div id="instructionContent" class="modal-body">
                <h3>程式碼運行目的與功能說明</h3>
                <p>此應用程式旨在提供一個多功能的工具，幫助使用者將不同來源的內容（包括純文字、圖片、PDF、DOCX 和 TXT 文件）轉換為結構化的階層式摘要，並進一步將該摘要視覺化為可互動的節點式心智圖。其核心目的是利用 Gemini API 的強大生成能力，自動化內容理解、摘要和視覺化的過程，提升資訊整理與學習的效率。</p>

                <h3>各功能特性與如何使用詳盡說明</h3>

                <h4>1. API Key 設定 (選填)</h4>
                <ul>
                  <li><strong>功能特性</strong>：允許使用者輸入自己的 Gemini API Key。在 Canvas 環境下，API Key 會自動提供，無需手動輸入。</li>
                  <li><strong>如何使用</strong>：在「API Key 設定」區塊的輸入框中，貼上您的 Gemini API Key，然後點擊「設定 API Key」。</li>
                </ul>

                <h4>2. 文本輸入與文件上傳</h4>
                <ul>
                  <li><strong>功能特性</strong>：支援直接輸入文本，或上傳圖片 (JPG, PNG)、文檔 (PDF, DOCX, TXT)。文件上傳後會顯示預覽。</li>
                  <li><strong>如何使用</strong>：使用「文本輸入」或「文件上傳」分頁來提供您的內容。</li>
                </ul>

                <h4>3. 生成階層式摘要</h4>
                <ul>
                  <li><strong>功能特性</strong>：根據輸入內容生成「主題 -> 大綱 -> 章節 -> 重點」四個層次的摘要。</li>
                  <li><strong>如何使用</strong>：輸入內容後，點擊「生成階層式摘要」按鈕。</li>
                </ul>
                
                <h4>4. AI 章節分析與問答 (含外部資訊)</h4>
                <ul>
                  <li><strong>功能特性</strong>：在生成摘要後，每個大綱、章節和重點旁都會出現「AI分析」按鈕。點擊後，AI會結合原始資料與外部知識對該章節進行深入分析。在問答環節，若內部資料不足，AI會模擬搜尋外部資料來回答，並在回答中標明外部資訊來源。</li>
                  <li><strong>如何使用</strong>：
                    <ol>
                      <li>生成階層式摘要。</li>
                      <li>點擊任一章節旁的「AI分析」按鈕。</li>
                      <li>在彈出視窗中查看AI的分析報告。</li>
                      <li>在下方的輸入框中，針對該章節內容提出您的問題，並按「發送」。</li>
                      <li>查看AI的回答，注意是否有標示「外部資訊補充」的區塊。</li>
                      <li>完成後，按「結束」關閉視窗。</li>
                    </ol>
                  </li>
                </ul>

                <h4>5. 生成心智圖 (視覺化節點)</h4>
                <ul>
                  <li><strong>功能特性</strong>：
                    <ul>
                      <li>根據摘要生成視覺化的互動式心智圖。</li>
                      <li><strong>節點與連線</strong>：心智圖以節點和連線的方式呈現，更加直觀。</li>
                      <li><strong>展開/折疊</strong>：點擊節點可以展開或折疊其子節點。</li>
                      <li><strong>顏色標示</strong>：不同層級的節點以不同顏色標示。</li>
                      <li><strong>縮放與平移</strong>：可以使用滑鼠滾輪縮放，按住拖曳來平移心智圖。</li>
                      <li><strong>心智圖展現方式</strong>：
                          <ul>
                              <li>**線條式褶疊**：傳統心智圖樣式，節點間有線條連接，可展開/折疊子節點。</li>
                              <li>**階層式列表 (無線條)**：以縮排列表形式呈現，無連接線條，但同樣可展開/折疊層級。</li>
                          </ul>
                      </li>
                      <li><strong>下載</strong>：支援下載為可互動的 HTML 或靜態的 PDF。</li>
                    </ul>
                  </li>
                  <li><strong>如何使用</strong>：
                    <ol>
                      <li>成功生成摘要後，點擊「根據摘要生成心智圖」按鈕。</li>
                      <li>等待心智圖渲染完成。</li>
                      <li>在「心智圖展現方式」中選擇您偏好的顯示樣式（線條式褶疊或階層式列表）。</li>
                      <li>點擊節點進行互動（展開/折疊），或使用下載按鈕保存。</li>
                    </ol>
                  </li>
                </ul>

                <h4>6. 檔案內容描述</h4>
                 <ul>
                  <li><strong>功能特性</strong>：生成一份包含主題、大綱、描述、重點、建議等結構的詳細分析報告。</li>
                  <li><strong>如何使用</strong>：輸入內容後，點擊「生成內容描述」按鈕。</li>
                </ul>


                <h3>錯誤訊息如何處理</h3>
                <p>應用程式內建了錯誤處理機制。當發生錯誤時（如 API Key 無效、網路問題、內容生成失敗），會在頁面上方顯示紅色的錯誤訊息框，並在右下角彈出提示。請根據錯誤訊息檢查您的設定或輸入內容。</p>

                <h3>有何注意事項</h3>
                <ol>
                  <li><strong>API Key 安全性</strong>：請妥善保管您的 API Key，不要洩漏。</li>
                  <li><strong>內容限制</strong>：過長或過於複雜的內容可能會影響生成速度和品質。</li>
                  <li><strong>網路連線</strong>：需要穩定的網路連線來呼叫 API。</li>
                  <li><strong>瀏覽器兼容性</strong>：建議使用最新版本的 Chrome, Firefox, Edge 等現代瀏覽器。</li>
                </ol>
            </div>
        </div>
    </div>

    <!-- 分析與問答 Modal -->
    <div id="analysisModal" class="modal-overlay">
        <div class="modal-content !max-w-4xl"> <!-- 使用 !max-w-4xl 來強制更大的寬度 -->
            <div class="modal-body">
                <h2 id="analysisModalTitle" class="text-2xl font-bold text-gray-800 mb-4 border-b pb-3">章節分析與問答</h2>
                <div id="analysisModalContent" class="space-y-6">
                    <!-- 分析結果區 -->
                    <div>
                        <h3 class="text-xl font-semibold text-primary mb-2">AI 綜合分析</h3>
                        <div id="analysisResult" class="p-4 bg-gray-50 rounded-lg min-h-[150px] max-h-[25vh] overflow-y-auto border prose prose-sm max-w-none">
                            <!-- AI 分析將會顯示在這裡 -->
                        </div>
                    </div>

                    <!-- 問答區 -->
                    <div>
                        <h3 class="text-xl font-semibold text-primary mb-2">根據本章節提問</h3>
                        <div id="qaChatHistory" class="p-4 bg-gray-50 rounded-lg min-h-[150px] max-h-[25vh] overflow-y-auto border mb-4">
                            <!-- 問答歷史將會顯示在這裡 -->
                        </div>
                        <div class="flex gap-2 items-center">
                            <input type="text" id="qaInput" class="flex-grow p-3 border rounded-lg focus:ring-2 focus:ring-primary focus:border-transparent outline-none transition" placeholder="請輸入您的問題...">
                            <button id="qaAskBtn" class="btn btn-primary">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.428A1 1 0 0010 16.57l5.318-1.518a1 1 0 001.17-1.41l-7-14z" />
                                </svg>
                                <span>發送</span>
                                <span id="qaLoadingSpinner" class="loading-spinner hidden ml-2"></span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-6 text-right border-t pt-4">
                <button id="endAnalysisBtn" class="btn btn-secondary">結束</button>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-2">階層式心智圖生成器 - Pro (視覺化節點)</h1>
            <p class="text-lg text-gray-600 mb-4">支持文本、圖片、PDF、TXT和DOCX文件，生成多層次摘要與視覺化心智圖</p>
            <button id="showInstructionsBtn" class="btn btn-secondary inline-flex items-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zm-2 2a1 1 0 00-1 1v3a1 1 0 102 0v-3a1 1 0 00-1-1zm3 0a1 1 0 00-1 1v3a1 1 0 102 0v-3a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
                操作說明
            </button>
        </div>

        <div class="api-key-section">
            <div class="section-header">
                <div class="section-header-title">
                    <div class="section-icon">K</div>
                    <h2>API Key 設定 (選填)</h2>
                </div>
            </div>
            <p class="text-gray-600 text-sm">
                在 Canvas 環境中，API Key 會自動提供。如果您在其他環境運行或使用特定模型，請在此輸入您的 Gemini API Key。
            </p>
            <input type="password" id="apiKeyInput" placeholder="在此輸入您的 Gemini API Key...">
            <p class="text-gray-600 text-xs mt-1">
                如何取得 Gemini API Key：<br>
                1. 前往 <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-600 hover:underline">Google AI Studio</a>。<br>
                2. 登入您的 Google 帳戶。<br>
                3. 點選「取得 API 金鑰」或「建立 API 金鑰」。<br>
                4. 選擇或建立一個 Google Cloud 專案。<br>
                5. 複製生成的 API 金鑰並貼到上方輸入框。
            </p>
            <div class="action-buttons">
                <button id="setApiKeyBtn" class="btn btn-primary">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clip-rule="evenodd" />
                    </svg>
                    設定 API Key
                </button>
                <button id="clearApiKeyBtn" class="btn btn-danger">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    清除 API Key
                </button>
            </div>
            <p id="apiKeyStatus" class="text-sm text-center font-medium py-2 px-4 rounded-lg bg-blue-50 text-blue-700"></p>
        </div>

        <div class="input-section">
            <div class="tabs">
                <div class="tab active" data-tab="text">文本輸入</div>
                <div class="tab" data-tab="file">文件上傳</div>
            </div>
            
            <div id="textTab" class="tab-content active">
                <div class="section-header">
                    <div class="section-header-title">
                        <div class="section-icon">T</div>
                        <h2>輸入內容</h2>
                    </div>
                </div>
                <textarea id="textInput" class="w-full border border-gray-300 p-4 rounded-lg focus:ring-indigo-500 focus:border-indigo-500" placeholder="請輸入您想轉換成心智圖的文字內容..."></textarea>
            </div>
            
            <div id="fileTab" class="tab-content">
                <div class="section-header">
                    <div class="section-header-title">
                        <div class="section-icon">F</div>
                        <h2>上傳文件</h2>
                    </div>
                </div>
                <p class="text-gray-600 text-sm mb-4">支持圖片、PDF、TXT和DOCX格式文件</p>
                
                <div class="file-upload-section">
                    <div class="file-upload-card">
                        <h3>圖片文件</h3>
                        <div class="file-format-icons">
                            <div class="file-icon image">JPG</div>
                            <div class="file-icon image">PNG</div>
                        </div>
                        <label for="imageInput" class="file-input-label">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4 5a2 2 0 00-2 2v8a2 2 0 002 2h12a2 2 0 002-2V7a2 2 0 00-2-2h-1.586a1 1 0 01-.707-.293l-1.121-1.121A2 2 0 0011.172 3H8.828a2 2 0 00-1.414.586L6.293 4.707A1 1 0 015.586 5H4zm6 9a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                            </svg>
                            選擇圖片
                        </label>
                        <input type="file" id="imageInput" accept="image/*">
                        <button id="clearImageBtn" class="btn btn-secondary mt-3 w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            清除圖片
                        </button>
                    </div>
                    
                    <div class="file-upload-card">
                        <h3>文檔文件</h3>
                        <div class="file-format-icons">
                            <div class="file-icon pdf">PDF</div>
                            <div class="file-icon docx">DOCX</div>
                            <div class="file-icon txt">TXT</div>
                        </div>
                        <label for="docInput" class="file-input-label">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V8z" clip-rule="evenodd" />
                            </svg>
                            選擇文檔
                        </label>
                        <input type="file" id="docInput" accept=".pdf,.docx,.txt">
                        <button id="clearDocBtn" class="btn btn-secondary mt-3 w-full">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            清除文檔
                        </button>
                    </div>
                </div>
                
                <div class="mt-6">
                    <div id="imagePreviewContainer" class="hidden">
                        <h3 class="text-lg font-medium text-gray-700 mb-3">圖片預覽</h3>
                        <img id="imagePreview" src="#" alt="圖片預覽">
                    </div>
                    
                    <div id="docPreviewContainer" class="hidden">
                         <!-- NEW: Collapsible Header for Doc Preview -->
                        <div class="collapsible-header">
                            <h3 class="text-lg font-medium text-gray-700">文件內容預覽</h3>
                            <svg class="toggle-icon" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                            </svg>
                        </div>
                        <!-- NEW: Collapsible Content Wrapper -->
                        <div class="collapsible-content">
                            <div id="docPreview" class="doc-preview"></div>
                            <div class="file-info">
                                <span id="fileName"></span>
                                <span id="fileSize"></span>
                                <span id="pageCount"></span>
                            </div>
                        </div>
                    </div>
                    
                    <div id="processingIndicator" class="hidden mt-4">
                        <p class="text-gray-600 text-center mb-2">正在處理文件...</p>
                        <div class="progress-bar">
                            <div class="progress" id="fileProgress"></div>
                        </div>
                    </div>
                </div>
            </div>
            <p id="errorMessage" class="error-message hidden"></p>
        </div>

        <!-- 檔案內容描述區塊 -->
        <div class="description-section">
            <div class="section-header collapsible-header">
                <div class="flex-grow flex justify-between items-center">
                    <div class="section-header-title">
                        <div class="section-icon">D</div>
                        <h2>檔案內容描述</h2>
                    </div>
                    <button id="downloadDescriptionPdfBtn" class="btn btn-download" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                        下載 PDF
                    </button>
                </div>
                <svg class="toggle-icon ml-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                </svg>
            </div>
            <div class="collapsible-content">
                <p class="text-gray-600 text-sm mb-4">根據上方輸入的內容，生成詳細的結構化分析報告。</p>
                <button id="generateDescriptionBtn" class="btn btn-primary w-full flex items-center justify-center">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M7 3a1 1 0 000 2h6a1 1 0 100-2H7zM4 7a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1zM2 11a2 2 0 012-2h12a2 2 0 012 2v4a2 2 0 01-2-2H4a2 2 0 01-2-2v-4z" />
                    </svg>
                    生成內容描述
                    <span id="loadingSpinnerDescription" class="loading-spinner hidden ml-2"></span>
                </button>
                <div id="descriptionOutput" class="summary-content mt-4">
                    <p class="text-gray-500 text-center py-8">內容描述將會顯示在這裡。</p>
                </div>
            </div>
        </div>

        <div class="summary-section">
            <div class="section-header collapsible-header">
                <div class="flex-grow flex justify-between items-center">
                    <div class="section-header-title">
                        <div class="section-icon">S</div>
                        <h2>階層式摘要</h2>
                    </div>
                    <div class="flex gap-2 flex-wrap">
                        <button id="readAloudBtn" class="btn btn-download" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path d="M6 3a1 1 0 011-1h.01a1 1 0 010 2H7a1 1 0 01-1-1zM3 3a1 1 0 011-1h.01a1 1 0 110 2H4a1 1 0 01-1-1zm7.293 9.293a1 1 0 011.414 0l2 2a1 1 0 01-1.414 1.414L12 14.414l-1.293 1.293a1 1 0 01-1.414-1.414l2-2zM4 9a1 1 0 011-1h10a1 1 0 110 2H5a1 1 0 01-1-1z" />
                            </svg>
                            <span id="readAloudBtnText">語音導讀</span>
                        </button>
                        <button id="downloadTxtBtn" class="btn btn-download" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                               <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6 13a1 1 0 100 2h8a1 1 0 100-2H6zM7 8a1 1 0 011-1h4a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd" />
                            </svg>
                            下載TXT檔案
                        </button>
                        <button id="downloadSummaryPdfBtn" class="btn btn-download" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                            下載 PDF
                        </button>
                    </div>
                </div>
                 <svg class="toggle-icon ml-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                </svg>
            </div>
            <div class="collapsible-content">
                <button id="generateSummaryBtn" class="btn btn-primary w-full flex items-center justify-center mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" />
                    </svg>
                    生成階層式摘要
                    <span id="loadingSpinnerSummary" class="loading-spinner hidden ml-2"></span>
                </button>
                <div id="summaryOutput" class="summary-content mt-4">
                    <p class="text-gray-500 text-center py-8">摘要將會顯示在這裡。</p>
                </div>
            </div>
        </div>

        <div class="output-section">
            <div class="section-header collapsible-header">
                <div class="flex-grow flex justify-between items-center">
                    <div class="section-header-title">
                        <div class="section-icon">M</div>
                        <h2>心智圖 (思維圖) 輸出</h2>
                    </div>
                    <div class="flex gap-2">
                        <button id="downloadMindmapHtmlBtn" class="btn btn-download" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                               <path fill-rule="evenodd" d="M6.707 7.293a1 1 0 010 1.414L3.414 12l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                               <path fill-rule="evenodd" d="M13.293 7.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L16.586 12l-3.293-3.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                            下載 HTML (動態心智圖)
                        </button>
                        <button id="downloadMindmapPdfBtn" class="btn btn-download" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L9 10.586V3a1 1 0 112 0v7.586l1.293-1.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                            下載 PDF
                        </button>
                    </div>
                </div>
                 <svg class="toggle-icon ml-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
                </svg>
            </div>
            <div class="collapsible-content">
                <button id="generateMindMapBtn" class="btn btn-accent w-full flex items-center justify-center my-4" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M12.316 3.051a1 1 0 01.633 1.265l-4 12a1 1 0 11-1.898-.632l4-12a1 1 0 011.265-.633zM5.707 6.293a1 1 0 010 1.414L3.414 10l2.293 2.293a1 1 0 11-1.414 1.414l-3-3a1 1 0 010-1.414l3-3a1 1 0 011.414 0zm8.586 0a1 1 0 011.414 0l3 3a1 1 0 010 1.414l-3 3a1 1 0 11-1.414-1.414L16.586 12l-3.293-3.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    根據摘要生成心智圖
                    <span id="loadingSpinnerMindMap" class="loading-spinner hidden ml-2"></span>
                </button>
                <!-- Mind Map Display Style Selection -->
                <div class="flex items-center gap-4 mb-4">
                    <span class="text-gray-700 font-medium">心智圖展現方式:</span>
                    <label class="inline-flex items-center">
                        <input type="radio" name="mindmap_style" value="line" class="form-radio h-4 w-4 text-primary" checked>
                        <span class="ml-2 text-gray-700">線條式褶疊</span>
                    </label>
                    <label class="inline-flex items-center">
                        <input type="radio" name="mindmap_style" value="no-line" class="form-radio h-4 w-4 text-primary">
                        <span class="ml-2 text-gray-700">階層式列表 (無線條)</span>
                    </label>
                </div>
                <div class="level-indicator">
                    <div class="level-item">
                        <div class="level-color" style="background: var(--color-level-0);"></div>
                        <span>主題</span>
                    </div>
                    <div class="level-item">
                        <div class="level-color" style="background: var(--color-level-1);"></div>
                        <span>大綱</span>
                    </div>
                    <div class="level-item">
                        <div class="level-color" style="background: var(--color-level-2);"></div>
                        <span>章節</span>
                    </div>
                    <div class="level-item">
                        <div class="level-color" style="background: var(--color-level-3);"></div>
                        <span>重點</span>
                    </div>
                </div>
                <div id="mindMapOutput" class="mind-map-container mt-4">
                    <p class="text-gray-500 text-center py-12">心智圖將會顯示在這裡。</p>
                </div>
            </div>
        </div>

    </div>

    <script type="module">
        // 全域變數與 DOM 元素獲取
        const { jsPDF } = window.jspdf;
        const textInput = document.getElementById('textInput');
        const imageInput = document.getElementById('imageInput');
        const docInput = document.getElementById('docInput');
        const imagePreview = document.getElementById('imagePreview');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const docPreviewContainer = document.getElementById('docPreviewContainer');
        const docPreview = document.getElementById('docPreview');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const pageCount = document.getElementById('pageCount');
        const clearImageBtn = document.getElementById('clearImageBtn');
        const clearDocBtn = document.getElementById('clearDocBtn');
        const generateSummaryBtn = document.getElementById('generateSummaryBtn');
        const generateMindMapBtn = document.getElementById('generateMindMapBtn');
        const loadingSpinnerSummary = document.getElementById('loadingSpinnerSummary');
        const loadingSpinnerMindMap = document.getElementById('loadingSpinnerMindMap');
        const errorMessage = document.getElementById('errorMessage');
        const mindMapOutput = document.getElementById('mindMapOutput');
        const summaryOutput = document.getElementById('summaryOutput');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const setApiKeyBtn = document.getElementById('setApiKeyBtn');
        const clearApiKeyBtn = document.getElementById('clearApiKeyBtn');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const processingIndicator = document.getElementById('processingIndicator');
        const fileProgress = document.getElementById('fileProgress');
        const downloadSummaryPdfBtn = document.getElementById('downloadSummaryPdfBtn');
        const downloadMindmapPdfBtn = document.getElementById('downloadMindmapPdfBtn');
        const downloadMindmapHtmlBtn = document.getElementById('downloadMindmapHtmlBtn');

        // Modal elements
        const showInstructionsBtn = document.getElementById('showInstructionsBtn');
        const instructionModal = document.getElementById('instructionModal');
        const closeModalBtn = document.getElementById('closeModalBtn');

        // 新增的描述區塊元素
        const generateDescriptionBtn = document.getElementById('generateDescriptionBtn');
        const loadingSpinnerDescription = document.getElementById('loadingSpinnerDescription');
        const descriptionOutput = document.getElementById('descriptionOutput');
        const downloadDescriptionPdfBtn = document.getElementById('downloadDescriptionPdfBtn');

        // 心智圖樣式選擇器
        const mindMapStyleRadios = document.querySelectorAll('input[name="mindmap_style"]');

        // 新增：分析 Modal 的元素
        const analysisModal = document.getElementById('analysisModal');
        const analysisModalTitle = document.getElementById('analysisModalTitle');
        const analysisResult = document.getElementById('analysisResult');
        const qaChatHistory = document.getElementById('qaChatHistory');
        const qaInput = document.getElementById('qaInput');
        const qaAskBtn = document.getElementById('qaAskBtn');
        const qaLoadingSpinner = document.getElementById('qaLoadingSpinner');
        const endAnalysisBtn = document.getElementById('endAnalysisBtn');
        
        // 語音導讀元素
        const readAloudBtn = document.getElementById('readAloudBtn');
        const readAloudBtnText = document.getElementById('readAloudBtnText');
        const downloadTxtBtn = document.getElementById('downloadTxtBtn');

        let base64Image = null;
        let imageMimeType = null;
        let userProvidedApiKey = '';
        let generatedSummary = '';
        let optimizedNarrationScript = ''; // **新增**: 用於儲存優化後的導讀稿
        let currentFileType = null;
        let mindMapJsonData = null; 
        let currentMindMapStyle = 'line';
        let isReading = false;
        let wasManuallyStopped = false; // Flag to check if speech was stopped by user

        // 用於儲存當前分析上下文的變數
        let currentAnalysisContext = {
            chapterContent: '',
            originalInput: '',
            analysis: '',
            history: []
        };

        // NEW: Collapsible section logic
        document.addEventListener('click', function (event) {
            const header = event.target.closest('.collapsible-header');
            if (!header) return;

            // Prevent buttons inside the header from triggering collapse
            if (event.target.closest('button') || event.target.closest('a')) {
                 return;
            }

            const content = header.nextElementSibling;
            const icon = header.querySelector('.toggle-icon');

            if (content && content.classList.contains('collapsible-content')) {
                content.classList.toggle('collapsed');
                if (icon) {
                    icon.classList.toggle('collapsed');
                }
            }
        });


        // Tab 切換邏輯
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabId = tab.getAttribute('data-tab');
                tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                tabContents.forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}Tab`).classList.add('active');
                if (tabId === 'text') {
                    clearImageInput();
                    clearDocInput();
                } else {
                    textInput.value = '';
                    resetOutputs();
                }
            });
        });

        // API Key 管理功能
        function updateApiKeyStatus() {
            if (userProvidedApiKey) {
                apiKeyStatus.textContent = 'API Key 已設定。';
                apiKeyStatus.classList.remove('bg-yellow-50', 'text-yellow-700', 'bg-red-50', 'text-red-700');
                apiKeyStatus.classList.add('bg-green-50', 'text-green-700');
            } else {
                apiKeyStatus.textContent = 'API Key 未設定。';
                apiKeyStatus.classList.remove('bg-green-50', 'text-green-700');
                apiKeyStatus.classList.add('bg-yellow-50', 'text-yellow-700');
            }
        }
        
        setApiKeyBtn.addEventListener('click', () => {
            const key = apiKeyInput.value.trim();
            if (key) {
                userProvidedApiKey = key;
                apiKeyInput.value = '';
                updateApiKeyStatus();
                showFloatingInfo('API Key 已成功設定！', 'success');
            } else {
                errorMessage.textContent = '請輸入有效的 API Key。';
                errorMessage.classList.remove('hidden');
            }
        });
        
        clearApiKeyBtn.addEventListener('click', () => {
            userProvidedApiKey = '';
            apiKeyInput.value = '';
            updateApiKeyStatus();
            errorMessage.classList.add('hidden');
            showFloatingInfo('API Key 已清除！', 'info');
        });
        
        updateApiKeyStatus();

        // 文件與圖片處理功能
        imageInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    imagePreview.src = e.target.result;
                    imagePreviewContainer.classList.remove('hidden');
                    docPreviewContainer.classList.add('hidden');
                    base64Image = e.target.result.split(',')[1];
                    imageMimeType = file.type;
                    textInput.value = '';
                    resetOutputs();
                    showFloatingInfo('圖片已成功上傳！', 'success');
                };
                reader.readAsDataURL(file);
            }
        });

        docInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            clearImageInput();
            textInput.value = '';
            processingIndicator.classList.remove('hidden');
            fileProgress.style.width = '30%';
            try {
                const ext = file.name.split('.').pop().toLowerCase();
                let content = '';
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);
                if (ext === 'txt') {
                    content = await readTextFile(file);
                } else if (ext === 'docx') {
                    content = await readDocxFile(file);
                } else if (ext === 'pdf') {
                    content = await readPdfFile(file);
                } else {
                    throw new Error('不支援的文件格式');
                }
                fileProgress.style.width = '80%';
                // MODIFIED: Added user-friendly tip to the document preview
                docPreview.innerHTML = `
                    <p class="text-sm text-gray-500 mb-2 p-2 bg-gray-100 rounded">
                        <i><b>提示：</b>為保持頁面簡潔，此處僅顯示文件開頭部分。程式已讀取<b>完整內容</b>，請安心生成摘要。</i>
                    </p>
                    <pre class="whitespace-pre-wrap">${truncateText(content, 2000)}</pre>
                `;
                docPreviewContainer.classList.remove('hidden');
                imagePreviewContainer.classList.add('hidden');
                textInput.value = content;
                resetOutputs();
                showFloatingInfo('文件已成功上傳並解析！', 'success');
            } catch (error) {
                console.error('文件解析錯誤:', error);
                errorMessage.textContent = `文件解析失敗: ${error.message}`;
                errorMessage.classList.remove('hidden');
                showFloatingInfo(`文件解析失敗: ${error.message}`, 'error');
            } finally {
                processingIndicator.classList.add('hidden');
                fileProgress.style.width = '0%';
            }
        });

        function readTextFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file, 'UTF-8'); // 指定UTF-8讀取
            });
        }

        async function readDocxFile(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            pageCount.textContent = "DOCX文件";
            return result.value;
        }

        async function readPdfFile(file) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js`;
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
            let text = '';
            pageCount.textContent = `${pdf.numPages} 頁`;
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const content = await page.getTextContent();
                text += content.items.map(item => item.str).join(' ') + '\n\n';
                const progress = Math.round((i / pdf.numPages) * 50) + 30;
                fileProgress.style.width = `${progress}%`;
            }
            return text;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function truncateText(text, maxLength) {
            if (text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        }

        clearImageBtn.addEventListener('click', clearImageInput);
        clearDocBtn.addEventListener('click', clearDocInput);

        function clearImageInput() {
            imageInput.value = '';
            imagePreviewContainer.classList.add('hidden');
            imagePreview.src = '#';
            base64Image = null;
            imageMimeType = null;
            resetOutputs();
            showFloatingInfo('圖片已清除！', 'info');
        }

        function clearDocInput() {
            docInput.value = '';
            docPreviewContainer.classList.add('hidden');
            docPreview.innerHTML = '';
            fileName.textContent = '';
            fileSize.textContent = '';
            pageCount.textContent = '';
            textInput.value = '';
            resetOutputs();
            showFloatingInfo('文件已清除！', 'info');
        }

        function resetOutputs() {
            if (speechSynthesis.speaking) {
                wasManuallyStopped = true;
                speechSynthesis.cancel();
            }
            isReading = false;
            readAloudBtnText.textContent = '語音導讀';

            summaryOutput.innerHTML = '<p class="text-gray-500 text-center py-8">摘要將會顯示在這裡。</p>';
            mindMapOutput.innerHTML = '<p class="text-gray-500 text-center py-12">心智圖將會顯示在這裡。</p>';
            descriptionOutput.innerHTML = '<p class="text-gray-500 text-center py-8">內容描述將會顯示在這裡。</p>';
            generatedSummary = '';
            optimizedNarrationScript = ''; // **新增**: 重置導讀稿
            mindMapJsonData = null; 
            generateMindMapBtn.disabled = true;
            downloadSummaryPdfBtn.disabled = true;
            downloadMindmapPdfBtn.disabled = true;
            downloadMindmapHtmlBtn.disabled = true;
            downloadDescriptionPdfBtn.disabled = true;
            readAloudBtn.disabled = true;
            downloadTxtBtn.disabled = true;
        }

        textInput.addEventListener('input', resetOutputs);

        // 主要功能綁定
        generateSummaryBtn.addEventListener('click', handleGenerateSummary);
        generateMindMapBtn.addEventListener('click', handleGenerateMindMap);
        generateDescriptionBtn.addEventListener('click', handleGenerateDescription);
        downloadSummaryPdfBtn.addEventListener('click', () => downloadElementAsPdf('summaryOutput', '摘要.pdf', downloadSummaryPdfBtn));
        downloadMindmapPdfBtn.addEventListener('click', () => downloadElementAsPdf('mindMapOutput', '心智圖.pdf', downloadMindmapPdfBtn));
        downloadMindmapHtmlBtn.addEventListener('click', downloadMindmapAsHtml);
        downloadDescriptionPdfBtn.addEventListener('click', () => downloadElementAsPdf('descriptionOutput', '檔案內容描述.pdf', downloadDescriptionPdfBtn));
        readAloudBtn.addEventListener('click', handleReadAloud);
        downloadTxtBtn.addEventListener('click', handleDownloadSummaryTxt);


        // Modal event listeners
        showInstructionsBtn.addEventListener('click', () => {
            instructionModal.classList.add('active');
        });

        closeModalBtn.addEventListener('click', () => {
            instructionModal.classList.remove('active');
        });

        instructionModal.addEventListener('click', (e) => {
            if (e.target === instructionModal) {
                instructionModal.classList.remove('active');
            }
        });

        // 心智圖樣式選擇器事件監聽
        mindMapStyleRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentMindMapStyle = event.target.value;
                if (mindMapJsonData) {
                    renderMindMap(mindMapJsonData, currentMindMapStyle);
                }
            });
        });

        /**
         * 處理階層式摘要的生成，並接續生成優化後的導讀稿
         */
        async function handleGenerateSummary() {
            if (speechSynthesis.speaking) {
                wasManuallyStopped = true;
                speechSynthesis.cancel();
            }
            errorMessage.classList.add('hidden');
            summaryOutput.innerHTML = '<p class="text-gray-500 text-center py-8">正在生成階層式摘要...</p>';
            mindMapOutput.innerHTML = '<p class="text-gray-500 text-center py-12">心智圖將會顯示在這裡。</p>';
            loadingSpinnerSummary.classList.remove('hidden');
            generateSummaryBtn.disabled = true;
            generateMindMapBtn.disabled = true;
            downloadSummaryPdfBtn.disabled = true;
            downloadMindmapPdfBtn.disabled = true;
            downloadMindmapHtmlBtn.disabled = true;
            readAloudBtn.disabled = true;
            downloadTxtBtn.disabled = true;

            const content = textInput.value.trim();
            if (!content && !base64Image) {
                errorMessage.textContent = '請輸入文字或上傳文件以生成摘要。';
                errorMessage.classList.remove('hidden');
                loadingSpinnerSummary.classList.add('hidden');
                generateSummaryBtn.disabled = false;
                summaryOutput.innerHTML = '<p class="text-gray-500 text-center py-8">摘要將會顯示在這裡。</p>';
                return;
            }

            let finalApiKey = "";
            if (typeof __app_id === 'undefined' && !userProvidedApiKey) {
                 errorMessage.textContent = '請在上方設定您的 Gemini API Key。';
                 errorMessage.classList.remove('hidden');
                 loadingSpinnerSummary.classList.add('hidden');
                 generateSummaryBtn.disabled = false;
                 return;
            }
            finalApiKey = userProvidedApiKey;

            // 摘要提示
            const summaryPromptTemplate = `你是一位專業的內容架構師。請將以下內容，依照「主題 -> 大綱 -> 章節 -> 重點」的層次結構，進行深入且詳細的分析與整理。

**輸出要求：**
1.  **層次清晰**：嚴格按照四個層級進行組織。
2.  **內容完整**：確保涵蓋所有原始文本的關鍵概念和核心資訊。
3.  **格式化輸出**：使用清晰的標題和縮排來表示不同層級，方便閱讀。
4.  **純文本**：不要包含任何 JSON 或程式碼區塊。

**輸出格式範例：**
【主題】：[主題名稱]

    【大綱一】：[大綱一的標題]
        【章節 1.1】：[章節 1.1 的標題]
            - [重點 1.1.1]
            - [重點 1.1.2]
        【章節 1.2】：[章節 1.2 的標題]
            - [重點 1.2.1]

    【大綱二】：[大綱二的標題]
        【章節 2.1】：[章節 2.1 的標題]
            - [重點 2.1.1]

請開始分析以下內容：
`;

            let chatHistory = [];
            if (content) {
                const prompt = `${summaryPromptTemplate}\n${content}`;
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            } else if (base64Image) {
                const prompt = `${summaryPromptTemplate}\n請分析這張圖片的內容。`;
                 chatHistory.push({
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: imageMimeType, data: base64Image } }
                    ]
                });
            }

            const payload = { contents: chatHistory };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${finalApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 請求失敗，狀態碼: ${response.status}. ${errorText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    generatedSummary = result.candidates[0].content.parts[0].text.trim();
                    renderSummary(generatedSummary); // 渲染畫面上的摘要
                    generateMindMapBtn.disabled = false;
                    downloadSummaryPdfBtn.disabled = false;
                    showFloatingInfo('階層式摘要生成成功！', 'success');

                    // **新增**: 接續生成優化的導讀稿
                    await generateOptimizedNarration(finalApiKey);

                } else {
                    throw new Error('API 未返回有效的摘要內容。');
                }
            } catch (error) {
                console.error('摘要生成錯誤:', error);
                errorMessage.textContent = `摘要生成失敗: ${error.message}`;
                errorMessage.classList.remove('hidden');
                summaryOutput.innerHTML = '<p class="text-gray-500 text-center py-8">摘要生成失敗。</p>';
                showFloatingInfo(`摘要生成失敗: ${error.message}`, 'error');
            } finally {
                loadingSpinnerSummary.classList.add('hidden');
                generateSummaryBtn.disabled = false;
            }
        }

        /**
         * **新增**: 根據結構化摘要，生成優化後的語音導讀稿
         * @param {string} apiKey - 用於 API 請求的金鑰
         */
        async function generateOptimizedNarration(apiKey) {
            summaryOutput.innerHTML += '<p class="text-gray-500 text-center py-2 text-sm italic">正在生成優化導讀稿...</p>';
            
            const narrationPrompt = `你是一位專業的知識解說員與內容編劇。請將以下結構化的階層式摘要，改寫成一篇流暢、連貫、口語化的語音導讀稿。

**導讀稿要求：**
1.  **自然流暢**：將條列式的重點串聯成自然的段落，避免生硬的列表感。
2.  **移除結構詞**：完全移除如「【主題】」、「【大綱】」、「【章節】」、「-」等所有結構性標示詞。
3.  **豐富內容**：在不偏離原意的基礎上，可以適度加入轉折語、補充說明或提出引導性思考，讓內容更充實、更易於理解。例如，可以從整體主題開始介紹，然後自然地過渡到各個大綱和細節。
4.  **口語化**：使用親切、自然的語氣，就像在對人解說一樣。
5.  **專注內容**：最終輸出的文稿，只應包含純粹的導讀內容，不應有任何前言、後記或格式說明。

**請根據以下階層式摘要，開始撰寫語音導讀稿：**
---
${generatedSummary}
---
`;
            const payload = { contents: [{ role: "user", parts: [{ text: narrationPrompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error('導讀稿生成 API 請求失敗');
                
                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    optimizedNarrationScript = result.candidates[0].content.parts[0].text.trim();
                    showFloatingInfo('優化導讀稿已準備就緒！', 'success');
                } else {
                    throw new Error('API 未返回有效的導讀稿內容。');
                }
            } catch (error) {
                console.error('導讀稿生成錯誤:', error);
                showFloatingInfo('導讀稿優化失敗，將使用原始摘要。', 'warning');
                // 發生錯誤時，使用原始摘要作為備用
                optimizedNarrationScript = generatedSummary.replace(/【主題】:|【大綱.*?】:|【章節.*?】:|-/g, '').replace(/\n\s*\n/g, '\n');
            } finally {
                // 無論成功或失敗，都啟用按鈕
                readAloudBtn.disabled = false;
                downloadTxtBtn.disabled = false;
                // 移除"正在生成"的提示訊息
                const generatingMsg = summaryOutput.querySelector('p.italic');
                if (generatingMsg) generatingMsg.remove();
            }
        }

        /**
         * 渲染摘要內容，並為每個章節添加 "AI分析" 按鈕
         * @param {string} summaryText 摘要的純文字內容
         */
        function renderSummary(summaryText) {
            const lines = summaryText.split('\n').filter(line => line.trim() !== '');
            let htmlContent = '';

            const escapeHtml = (unsafe) => {
                 if (typeof unsafe !== 'string') return '';
                 return unsafe.replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            };

            lines.forEach(line => {
                let trimmedLine = line.trim();
                let level = 0;
                
                if (trimmedLine.startsWith('【主題】')) level = 0;
                else if (trimmedLine.startsWith('【大綱')) level = 1;
                else if (trimmedLine.startsWith('【章節')) level = 2;
                else if (trimmedLine.startsWith('- ')) {
                    level = 3;
                    trimmedLine = trimmedLine.substring(2).trim();
                } else {
                    const leadingSpaces = line.match(/^\s*/)[0].length;
                    if (leadingSpaces >= 12) level = 3;
                    else if (leadingSpaces >= 8) level = 2;
                    else if (leadingSpaces >= 4) level = 1;
                }

                let analysisButton = '';
                // 為大綱、章節、重點層級（1, 2, 3）添加分析按鈕
                if (level >= 1 && level <= 3) {
                    analysisButton = `<button class="btn btn-secondary btn-sm ml-4 analyze-btn" data-content="${escapeHtml(trimmedLine)}">AI分析</button>`;
                }

                htmlContent += `
                    <div class="flex justify-between items-center my-1 py-1">
                        <p class="summary-level-${level} flex-grow">${trimmedLine}</p>
                        ${analysisButton}
                    </div>
                `;
            });
            summaryOutput.innerHTML = htmlContent;
        }


        /**
         * 處理階層式心智圖的生成
         */
        async function handleGenerateMindMap() {
            errorMessage.classList.add('hidden');
            mindMapOutput.innerHTML = '<p class="text-gray-500 text-center py-12">正在根據階層式摘要生成心智圖...</p>';
            loadingSpinnerMindMap.classList.remove('hidden');
            generateMindMapBtn.disabled = true;
            generateSummaryBtn.disabled = true;
            downloadMindmapPdfBtn.disabled = true;
            downloadMindmapHtmlBtn.disabled = true;

            if (!generatedSummary) {
                errorMessage.textContent = '請先生成摘要才能生成心智圖。';
                errorMessage.classList.remove('hidden');
                loadingSpinnerMindMap.classList.add('hidden');
                generateMindMapBtn.disabled = false;
                generateSummaryBtn.disabled = false;
                return;
            }

            let finalApiKey = "";
            if (typeof __app_id === 'undefined' && !userProvidedApiKey) {
                 errorMessage.textContent = '請在上方設定您的 Gemini API Key。';
                 errorMessage.classList.remove('hidden');
                 loadingSpinnerMindMap.classList.add('hidden');
                 generateMindMapBtn.disabled = false;
                 generateSummaryBtn.disabled = false;
                 return;
            }
            finalApiKey = userProvidedApiKey;

            // JSON 提示
            const jsonSchemaPrompt = `你是一位專業的心智圖結構化專家。請將以下經過層次化整理的摘要，轉換為一個深度巢狀的 JSON 物件，以供心智圖生成使用。

**輸入的摘要結構：**
輸入的摘要遵循「主題 -> 大綱 -> 章節 -> 重點」的層次。

**JSON 輸出要求：**
1.  **嚴格的 JSON 格式**：只返回純粹、有效、無誤的 JSON。禁止任何額外的文字、註解或程式碼區塊標記 (如 \`\`\`json)。
2.  **深度巢狀結構**：JSON 的巢狀結構必須精確反映輸入摘要的「主題 -> 大綱 -> 章節 -> 重點」四個層級。
3.  **鍵值對**：
    -   使用 "mainNode" 作為最頂層的主題名稱。
    -   在 "children" 陣列中，使用 "node" 作為每個節點的標題。
    -   使用 "children" 作為包含子節點的陣列。
    -   最底層的「重點」應作為其父「章節」節點的子節點，且自身沒有 "children" 屬性。

**JSON 結構範例 (對應摘要結構)：**
{
  "mainNode": "[主題名稱]",
  "children": [
    {
      "node": "[大綱一的標題]",
      "children": [
        {
          "node": "[章節 1.1 的標題]",
          "children": [
            { "node": "[重點 1.1.1]" },
            { "node": "[重點 1.1.2]" }
          ]
        }
      ]
    }
  ]
}

**請根據以下摘要內容，生成對應的 JSON 物件：**
${generatedSummary}`;

            const payload = {
                contents: [{ role: "user", parts: [{ text: jsonSchemaPrompt }] }],
                generationConfig: {
                    responseMimeType: "application/json"
                }
            };

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${finalApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 請求失敗，狀態碼: ${response.status}. ${errorText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    let rawJsonString = result.candidates[0].content.parts[0].text;
                    mindMapJsonData = JSON.parse(rawJsonString); 
                    if (mindMapJsonData && mindMapJsonData.mainNode) {
                        renderMindMap(mindMapJsonData, currentMindMapStyle);
                        downloadMindmapPdfBtn.disabled = false;
                        downloadMindmapHtmlBtn.disabled = false;
                        showFloatingInfo('心智圖生成成功！', 'success');
                    } else {
                        throw new Error('API 回應的 JSON 結構無效。');
                    }
                } else {
                    throw new Error('API 未返回有效的心智圖內容。');
                }
            } catch (error) {
                console.error('心智圖生成錯誤:', error);
                errorMessage.textContent = `心智圖生成失敗: ${error.message}。請檢查 API 回應是否為有效的 JSON。`;
                errorMessage.classList.remove('hidden');
                mindMapOutput.innerHTML = '<p class="text-gray-500 text-center py-12">心智圖生成失敗。</p>';
                showFloatingInfo(`心智圖生成失敗: ${error.message}`, 'error');
            } finally {
                loadingSpinnerMindMap.classList.add('hidden');
                generateMindMapBtn.disabled = false;
                generateSummaryBtn.disabled = false;
            }
        }

        // D3 心智圖渲染函數
        function renderMindMap(mindMapData, displayStyle) {
            mindMapOutput.innerHTML = '';
            if (!mindMapData || !mindMapData.mainNode) {
                mindMapOutput.innerHTML = '<p class="text-gray-500 text-center py-12">無法生成心智圖，資料無效。</p>';
                return;
            }

            if (displayStyle === 'line') {
                if (typeof d3 === 'undefined') {
                    console.error('D3.js is not loaded for line style rendering!');
                    mindMapOutput.innerHTML = '<p class="text-red-500 text-center py-12">D3.js 載入失敗，無法顯示線條式心智圖。</p>';
                    return;
                }

                const width = mindMapOutput.clientWidth;
                const initialHeight = 600;
                let i = 0;

                const d3FormattedData = {
                    node: mindMapData.mainNode,
                    children: mindMapData.children
                };
                
                const root = d3.hierarchy(d3FormattedData, d => d.children);
                root.x0 = initialHeight / 2;
                root.y0 = 0;

                if(root.children){
                    root.children.forEach(collapse);
                }

                const treeLayout = d3.tree().nodeSize([40, 250]);

                const svg = d3.select(mindMapOutput).append("svg")
                    .attr("width", width)
                    .attr("height", initialHeight)
                    .style("background-color", "var(--light-bg)")
                    .call(d3.zoom().on("zoom", (event) => {
                        g.attr("transform", event.transform);
                    }));

                const g = svg.append("g")
                    .attr("transform", `translate(150, ${initialHeight / 2})`);

                update(root);

                function collapse(d) {
                    if (d.children) {
                        d._children = d.children;
                        d._children.forEach(collapse);
                        d.children = null;
                    }
                }

                function update(source) {
                    const duration = 250;
                    const nodes = root.descendants();
                    const links = root.links();

                    treeLayout(root);

                    let left = root;
                    let right = root;
                    root.each(d => {
                        if (d.x < left.x) left = d;
                        if (d.x > right.x) right = d;
                    });

                    const newHeight = right.x - left.x + 100;
                    svg.transition().duration(duration).attr("height", newHeight);
                    g.transition().duration(duration).attr("transform", `translate(150, ${-left.x + 50})`);

                    const node = g.selectAll("g.node")
                        .data(nodes, d => d.id || (d.id = ++i));

                    const nodeEnter = node.enter().append("g")
                        .attr("class", "node")
                        .attr("transform", `translate(${source.y0},${source.x0})`)
                        .on("click", (event, d) => {
                            if (d.children) {
                                d._children = d.children;
                                d.children = null;
                            } else {
                                d.children = d._children;
                                d._children = null;
                            }
                            update(d);
                        });

                    nodeEnter.append("circle")
                        .attr("r", 1e-6)
                        .style("fill", d => d._children ? `var(--color-level-${d.depth % 5})` : "#fff");

                    nodeEnter.append("text")
                        .attr("x", d => (d.children || d._children) ? -15 : 15)
                        .attr("dy", ".35em")
                        .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                        .text(d => d.data.node)
                        .style("fill-opacity", 1e-6);

                    const nodeUpdate = node.merge(nodeEnter).transition()
                        .duration(duration)
                        .attr("transform", d => `translate(${d.y},${d.x})`);

                    nodeUpdate.select("circle")
                        .attr("r", 8)
                        .style("fill", d => d._children ? `var(--color-level-${d.depth % 5})` : "#fff")
                        .style("stroke", d => `var(--color-level-${d.depth % 5})`);

                    nodeUpdate.select("text")
                        .style("fill-opacity", 1);

                    const nodeExit = node.exit().transition()
                        .duration(duration)
                        .attr("transform", `translate(${source.y},${source.x})`)
                        .remove();

                    nodeExit.select("circle").attr("r", 1e-6);
                    nodeExit.select("text").style("fill-opacity", 1e-6);

                    const link = g.selectAll("path.link")
                        .data(links, d => d.target.id);

                    const linkEnter = link.enter().insert("path", "g")
                        .attr("class", "link")
                        .attr("d", d => {
                            const o = { x: source.x0, y: source.y0 };
                            return d3.linkHorizontal()({ source: o, target: o });
                        });

                    link.merge(linkEnter).transition()
                        .duration(duration)
                        .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

                    link.exit().transition()
                        .duration(duration)
                        .attr("d", d => {
                            const o = { x: source.x, y: source.y };
                            return d3.linkHorizontal()({ source: o, target: o });
                        })
                        .remove();

                    nodes.forEach(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                }
            } else if (displayStyle === 'no-line') {
                const rootElement = document.createElement('div');
                rootElement.className = 'mindmap-no-line-root';
                mindMapOutput.appendChild(rootElement);

                function createNodeRecursive(nodeData, depth) {
                    const nodeWrapper = document.createElement('div');
                    nodeWrapper.className = `node-item-wrapper`;

                    const nodeContentDiv = document.createElement('div');
                    nodeContentDiv.className = `node-content-display node-level-${depth % 5}`;
                    nodeContentDiv.style.marginLeft = `${depth * 20}px`; // Indentation

                    let toggleIcon = null;
                    if (nodeData.children && nodeData.children.length > 0) {
                        toggleIcon = document.createElement('span');
                        toggleIcon.className = 'expand-toggle font-bold';
                        toggleIcon.textContent = '▶'; 
                        nodeContentDiv.appendChild(toggleIcon);
                    } else {
                        const placeholderToggle = document.createElement('span');
                        placeholderToggle.className = 'expand-toggle';
                        placeholderToggle.style.visibility = 'hidden';
                        nodeContentDiv.appendChild(placeholderToggle);
                    }

                    const horizontalLine = document.createElement('span');
                    horizontalLine.className = 'horizontal-line';
                    nodeContentDiv.appendChild(horizontalLine);

                    const nodeTextSpan = document.createElement('span');
                    nodeTextSpan.className = 'node-text';
                    nodeTextSpan.textContent = nodeData.node;
                    nodeContentDiv.appendChild(nodeTextSpan);

                    nodeWrapper.appendChild(nodeContentDiv);

                    if (nodeData.children && nodeData.children.length > 0) {
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'children-container collapsed';
                        nodeWrapper.appendChild(childrenContainer);

                        nodeContentDiv.onclick = (event) => {
                            event.stopPropagation();
                            const isCollapsed = childrenContainer.classList.contains('collapsed');
                            if (isCollapsed) {
                                childrenContainer.classList.remove('collapsed');
                                childrenContainer.classList.add('expanded');
                                if (toggleIcon) toggleIcon.textContent = '▼';
                            } else {
                                childrenContainer.classList.remove('expanded');
                                childrenContainer.classList.add('collapsed');
                                if (toggleIcon) toggleIcon.textContent = '▶';
                            }
                        };

                        nodeData.children.forEach(child => {
                            childrenContainer.appendChild(createNodeRecursive(child, depth + 1));
                        });
                    }
                    return nodeWrapper;
                }
                const d3FormattedData = {
                    node: mindMapData.mainNode,
                    children: mindMapData.children
                };
                rootElement.appendChild(createNodeRecursive(d3FormattedData, 0));
            }
        }

        /**
         * 處理檔案內容描述的生成
         */
        async function handleGenerateDescription() {
            errorMessage.classList.add('hidden');
            descriptionOutput.innerHTML = '<p class="text-gray-500 text-center py-8">正在生成內容描述...</p>';
            loadingSpinnerDescription.classList.remove('hidden');
            generateDescriptionBtn.disabled = true;
            downloadDescriptionPdfBtn.disabled = true;

            const content = textInput.value.trim();
            if (!content && !base64Image) {
                errorMessage.textContent = '請輸入文字或上傳文件以生成描述。';
                errorMessage.classList.remove('hidden');
                loadingSpinnerDescription.classList.add('hidden');
                generateDescriptionBtn.disabled = false;
                descriptionOutput.innerHTML = '<p class="text-gray-500 text-center py-8">內容描述將會顯示在這裡。</p>';
                return;
            }

            let finalApiKey = "";
            if (typeof __app_id === 'undefined' && !userProvidedApiKey) {
                errorMessage.textContent = '請在上方設定您的 Gemini API Key。';
                errorMessage.classList.remove('hidden');
                loadingSpinnerDescription.classList.add('hidden');
                generateDescriptionBtn.disabled = false;
                return;
            }
            finalApiKey = userProvidedApiKey;

            // 描述提示
            const descriptionPrompt = `你是一位專業的分析師。請根據以下提供的內容，生成一份詳細的分析報告。報告必須包含以下八個部分（不包含相關報導網址），並以指定的 JSON 格式返回。

**JSON 輸出要求：**
1.  **嚴格的 JSON 格式**：只返回純粹、有效、無誤的 JSON。禁止任何額外的文字、註解或程式碼區塊標記 (如 \`\`\`json)。
2.  **完整的鍵值對**：確保 JSON 物件包含以下所有八個鍵：
    -   \`topic\`: (string) 內容的主題。
    -   \`outline\`: (array of strings) 條列式項目大綱。
    -   \`description\`: (string) 內容的簡單描述。
    -   \`summaryAndKeyPoints\`: (string) 簡單摘要與重點。
    -   \`purposeAndFunction\`: (string) 內容的目的與功能。
    -   \`suggestions\`: (string) 建議事項。
    -   \`precautions\`: (string) 注意事項。
    -   \`conclusion\`: (string) 總結。

**請開始分析以下內容，並生成對應的 JSON 分析報告：**
`;
            let chatHistory = [];
            if (content) {
                const prompt = `${descriptionPrompt}\n${content}`;
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            } else if (base64Image) {
                const prompt = `${descriptionPrompt}\n請分析這張圖片的內容。`;
                chatHistory.push({
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: imageMimeType, data: base64Image } }
                    ]
                });
            }
            
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json"
                }
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${finalApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 請求失敗，狀態碼: ${response.status}. ${errorText}`);
                }

                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const rawJsonString = result.candidates[0].content.parts[0].text;
                    const descriptionData = JSON.parse(rawJsonString);

                    const topic = descriptionData.topic || '';
                    if (topic) {
                        descriptionData.relatedUrls = [
                            { title: `Google 搜尋: "${topic} 研究報告"`, url: `https://www.google.com/search?q=${encodeURIComponent(topic + ' 研究報告')}` },
                            { title: `Google 搜尋: "${topic} 相關報導"`, url: `https://www.google.com/search?q=${encodeURIComponent(topic + ' 相關報導')}` },
                            { title: `Google 搜尋: "${topic} 最新發展"`, url: `https://www.google.com/search?q=${encodeURIComponent(topic + ' 最新發展')}` }
                        ];
                    } else {
                        descriptionData.relatedUrls = [];
                    }

                    renderDescription(descriptionData);
                    downloadDescriptionPdfBtn.disabled = false;
                    showFloatingInfo('內容描述生成成功！', 'success');
                } else {
                    throw new Error('API 未返回有效的描述內容。');
                }
            } catch (error) {
                console.error('內容描述生成錯誤:', error);
                errorMessage.textContent = `內容描述生成失敗: ${error.message}`;
                errorMessage.classList.remove('hidden');
                descriptionOutput.innerHTML = '<p class="text-gray-500 text-center py-8">內容描述生成失敗。</p>';
                showFloatingInfo(`內容描述生成失敗: ${error.message}`, 'error');
            } finally {
                loadingSpinnerDescription.classList.add('hidden');
                generateDescriptionBtn.disabled = false;
            }
        }

        /**
         * 渲染檔案內容描述
         * @param {object} data 包含描述內容的物件
         */
        function renderDescription(data) {
            if (!data) {
                descriptionOutput.innerHTML = '<p class="text-gray-500 text-center py-8">無法渲染描述內容，資料無效。</p>';
                return;
            }

            const escapeHtml = (unsafe) => {
                 if (typeof unsafe !== 'string') return '';
                 return unsafe
                     .replace(/&/g, "&amp;")
                     .replace(/</g, "&lt;")
                     .replace(/>/g, "&gt;")
                     .replace(/"/g, "&quot;")
                     .replace(/'/g, "&#039;");
            };

            let relatedUrlsHtml = '';
            if (data.relatedUrls && Array.isArray(data.relatedUrls) && data.relatedUrls.length > 0) {
                relatedUrlsHtml = `<ul>${data.relatedUrls.map(item => 
                    `<li>
                        <a href="${escapeHtml(item.url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(item.title)}</a>
                    </li>`
                ).join('')}</ul>`;
            } else {
                relatedUrlsHtml = '<p>無相關報導網址。</p>';
            }

            let htmlContent = `
                <h4>一、主題</h4>
                <p>${escapeHtml(data.topic || '無')}</p>
                
                <h4>二、條列式項目大綱</h4>
                ${(data.outline && data.outline.length > 0) ? `<ul>${data.outline.map(item => `<li>${escapeHtml(item)}</li>`).join('')}</ul>` : '<p>無</p>'}
                
                <h4>三、內容簡單描述</h4>
                <p>${escapeHtml(data.description || '無')}</p>
                
                <h4>四、簡單摘要與重點</h4>
                <p>${(data.summaryAndKeyPoints || '無').replace(/\n/g, '<br>')}</p>
                
                <h4>五、內容目的功能</h4>
                <p>${escapeHtml(data.purposeAndFunction || '無')}</p>
                
                <h4>六、建議事項</h4>
                <p>${escapeHtml(data.suggestions || '無')}</p>
                
                <h4>七、注意事項</h4>
                <p>${escapeHtml(data.precautions || '無')}</p>
                
                <h4>八、總結</h4>
                <p>${escapeHtml(data.conclusion || '無')}</p>

                <h4>九、相關報導網址</h4>
                ${relatedUrlsHtml}
            `;
            descriptionOutput.innerHTML = htmlContent;
        }
        
        /**
         * 將指定的 HTML 元素下載為 PDF
         * @param {string} elementId 要下載的元素的 ID
         * @param {string} filename 下載的 PDF 文件名
         * @param {HTMLElement} buttonElement 觸發下載的按鈕元素
         */
        async function downloadElementAsPdf(elementId, filename, buttonElement) {
            const elementToCapture = document.getElementById(elementId);
            if (!elementToCapture || elementToCapture.innerText.includes("將會顯示在這裡")) {
                showFloatingInfo('沒有可下載的內容', 'error');
                return;
            }

            const originalButtonText = buttonElement.innerHTML;
            buttonElement.innerHTML = '<span class="loading-spinner" style="border-top-color: var(--primary); width: 20px; height: 20px;"></span>';
            buttonElement.disabled = true;

            try {
                if (elementId === 'mindMapOutput' && mindMapJsonData) {
                    const tempContainer = document.createElement('div');
                    tempContainer.style.position = 'absolute';
                    tempContainer.style.left = '-9999px';
                    document.body.appendChild(tempContainer);
                    renderStaticMindMapForPdf(tempContainer, mindMapJsonData, currentMindMapStyle);
                    await new Promise(resolve => setTimeout(resolve, 500));
                    const canvas = await html2canvas(tempContainer, {
                        scale: 2,
                        useCORS: true,
                        backgroundColor: '#f8fafc'
                    });
                    document.body.removeChild(tempContainer);
                    const imgData = canvas.toDataURL('image/png');
                    const pdf = new jsPDF({
                        orientation: canvas.width > canvas.height ? 'l' : 'p',
                        unit: 'px',
                        format: [canvas.width, canvas.height]
                    });
                    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                    pdf.save(filename);

                } else {
                    // MODIFIED: Capture full scrollable content for PDF download
                    const canvas = await html2canvas(elementToCapture, {
                        scale: 2,
                        useCORS: true,
                        backgroundColor: '#ffffff',
                        width: elementToCapture.scrollWidth,
                        height: elementToCapture.scrollHeight,
                        windowWidth: elementToCapture.scrollWidth,
                        windowHeight: elementToCapture.scrollHeight
                    });
                    const imgData = canvas.toDataURL('image/png');
                    const pdf = new jsPDF({
                        orientation: canvas.width > canvas.height ? 'l' : 'p',
                        unit: 'px',
                        format: [canvas.width, canvas.height]
                    });
                    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
                    pdf.save(filename);
                }

                showFloatingInfo('PDF 已成功下載！', 'success');

            } catch (error) {
                console.error('PDF 生成失敗:', error);
                showFloatingInfo(`PDF 生成失敗: ${error.message}`, 'error');
            } finally {
                buttonElement.innerHTML = originalButtonText;
                buttonElement.disabled = false;
            }
        }

        function renderStaticMindMapForPdf(container, mindMapData, displayStyle) {
            container.innerHTML = '';
            const width = 1200;
            const d3FormattedData = { node: mindMapData.mainNode, children: mindMapData.children };
            const root = d3.hierarchy(d3FormattedData, d => d.children);
            const treeLayout = d3.tree().nodeSize([40, 250]);
            treeLayout(root);

            let left = root;
            let right = root;
            root.each(d => {
                if (d.x < left.x) left = d;
                if (d.x > right.x) right = d;
            });
            const height = right.x - left.x + 100;

            if (displayStyle === 'line') {
                const svg = d3.select(container).append("svg")
                    .attr("width", width)
                    .attr("height", height);

                const g = svg.append("g")
                    .attr("transform", `translate(150, ${-left.x + 50})`);

                g.selectAll(".link")
                    .data(root.links())
                    .enter().append("path")
                    .attr("class", "link")
                    .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x))
                    .style("stroke", d => `var(--color-level-${d.source.depth % 5})`);

                const node = g.selectAll(".node")
                    .data(root.descendants())
                    .enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${d.y},${d.x})`);

                node.append("circle")
                    .attr("r", 8)
                    .style("fill", d => d.children ? `var(--color-level-${d.depth % 5})` : "#fff")
                    .style("stroke", d => `var(--color-level-${d.depth % 5})`);

                node.append("text")
                    .attr("dy", ".35em")
                    .attr("x", d => d.children ? -15 : 15)
                    .style("text-anchor", d => d.children ? "end" : "start")
                    .text(d => d.data.node);
            } else if (displayStyle === 'no-line') {
                const rootElement = document.createElement('div');
                rootElement.className = 'mindmap-no-line-root';
                rootElement.style.width = `${width}px`;
                rootElement.style.overflow = 'visible'; 
                rootElement.style.maxHeight = 'none';
                container.appendChild(rootElement);

                function createNodeRecursiveStatic(nodeData, depth) {
                    const nodeWrapper = document.createElement('div');
                    nodeWrapper.className = `node-item-wrapper mb-1`;

                    const nodeContentDiv = document.createElement('div');
                    nodeContentDiv.className = `node-content-display node-level-${depth % 5}`;
                    nodeContentDiv.style.marginLeft = `${depth * 20}px`;
                    nodeContentDiv.style.boxShadow = '0 2px 5px rgba(0,0,0,0.08)';
                    nodeContentDiv.style.minHeight = '40px';

                    if (nodeData.children && nodeData.children.length > 0) {
                        const toggleIcon = document.createElement('span');
                        toggleIcon.className = 'expand-toggle font-bold';
                        toggleIcon.textContent = '▼';
                        nodeContentDiv.appendChild(toggleIcon);
                    } else {
                        const placeholderToggle = document.createElement('span');
                        placeholderToggle.className = 'expand-toggle';
                        placeholderToggle.style.visibility = 'hidden';
                        nodeContentDiv.appendChild(placeholderToggle);
                    }

                    const horizontalLine = document.createElement('span');
                    horizontalLine.className = 'horizontal-line';
                    nodeContentDiv.appendChild(horizontalLine);

                    const nodeTextSpan = document.createElement('span');
                    nodeTextSpan.className = 'node-text';
                    nodeTextSpan.textContent = nodeData.node;
                    nodeContentDiv.appendChild(nodeTextSpan);

                    nodeWrapper.appendChild(nodeContentDiv);

                    if (nodeData.children && nodeData.children.length > 0) {
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'children-container';
                        childrenContainer.style.overflow = 'visible';
                        childrenContainer.style.maxHeight = 'none';
                        childrenContainer.style.transition = 'none';

                        nodeData.children.forEach(child => {
                            childrenContainer.appendChild(createNodeRecursiveStatic(child, depth + 1));
                        });
                        nodeWrapper.appendChild(childrenContainer);
                    }
                    return nodeWrapper;
                }
                rootElement.appendChild(createNodeRecursiveStatic(d3FormattedData, 0));
            }
        }

        /**
         * 將心智圖下載為可互動的 HTML 檔案 
         */
        function downloadMindmapAsHtml() {
            if (!mindMapJsonData) {
                showFloatingInfo('沒有可下載的心智圖內容', 'error');
                return;
            }

            const styles = Array.from(document.styleSheets)
                .map(styleSheet => {
                    try {
                        return Array.from(styleSheet.cssRules)
                            .map(rule => rule.cssText)
                            .join('');
                    } catch (e) { return ''; }
                })
                .join('\n');
            
            const scriptFunctionString = `
                function renderMindMapInHtml(data, d3, displayStyle) {
                    const mindMapOutput = document.getElementById('mindMapDownloadContainer');
                    if (!mindMapOutput || !data || !data.mainNode) { 
                        mindMapOutput.innerHTML = '<p>無法渲染心智圖，資料無效。</p>';
                        return; 
                    }
                    mindMapOutput.innerHTML = '';

                    const fixedWidth = 1000;
                    const initialHeight = 600;
                    let i = 0;

                    const d3FormattedData = {
                        node: data.mainNode,
                        children: data.children
                    };

                    if (displayStyle === 'line') {
                        if (typeof d3 === 'undefined') {
                            mindMapOutput.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">D3.js 載入失敗，無法顯示線條式心智圖。</p>';
                            return;
                        }
                        const root = d3.hierarchy(d3FormattedData, d => d.children);
                        root.x0 = initialHeight / 2;
                        root.y0 = 0;

                        if(root.children){ root.children.forEach(collapse); }

                        const treeLayout = d3.tree().nodeSize([40, 250]);

                        const svg = d3.select(mindMapOutput).append("svg")
                            .attr("width", fixedWidth)
                            .attr("height", initialHeight)
                            .attr("viewBox", '0 0 ' + fixedWidth + ' ' + initialHeight)
                            .style("background-color", "var(--light-bg)")
                            .call(d3.zoom().on("zoom", (event) => {
                                g.attr("transform", event.transform);
                            }));

                        const g = svg.append("g")
                            .attr("transform", 'translate(100, ' + (initialHeight / 2) + ')');

                        update(root);

                        function collapse(d) {
                            if (d.children) {
                                d._children = d.children;
                                d._children.forEach(collapse);
                                d.children = null;
                            }
                        }

                        function update(source) {
                            const duration = 250;
                            treeLayout(root);
                            const nodes = root.descendants();
                            const links = root.links();

                            let left = root;
                            let right = root;
                            root.each(d => {
                                if (d.x < left.x) left = d;
                                if (d.x > right.x) right = d;
                            });

                            const newHeight = right.x - left.x + 120;
                            svg.transition().duration(duration)
                                .attr("height", newHeight)
                                .attr("viewBox", '0 0 ' + fixedWidth + ' ' + newHeight);
                            
                            g.transition().duration(duration).attr("transform", 'translate(100, ' + (-left.x + 60) + ')');

                            const node = g.selectAll("g.node")
                                .data(nodes, d => d.id || (d.id = ++i));

                            const nodeEnter = node.enter().append("g")
                                .attr("class", "node")
                                .attr("transform", 'translate(' + source.y0 + ',' + source.x0 + ')')
                                .on("click", (event, d) => {
                                    if (d.children) {
                                        d._children = d.children;
                                        d.children = null;
                                    } else {
                                        d.children = d._children;
                                        d._children = null;
                                    }
                                    update(d);
                                });

                            nodeEnter.append("circle")
                                .attr("r", 1e-6)
                                .style("fill", d => d._children ? 'var(--color-level-' + (d.depth % 5) + ')' : "#fff");

                            nodeEnter.append("text")
                                .attr("x", d => (d.children || d._children) ? -15 : 15)
                                .attr("dy", ".35em")
                                .attr("text-anchor", d => (d.children || d._children) ? "end" : "start")
                                .text(d => d.data.node)
                                .style("fill-opacity", 1e-6);

                            const nodeUpdate = node.merge(nodeEnter).transition()
                                .duration(duration)
                                .attr("transform", d => 'translate(' + d.y + ',' + d.x + ')');

                            nodeUpdate.select("circle")
                                .attr("r", 8)
                                .style("fill", d => d._children ? 'var(--color-level-' + (d.depth % 5) + ')' : "#fff")
                                .style("stroke", d => 'var(--color-level-' + (d.depth % 5) + ')');

                            nodeUpdate.select("text")
                                .style("fill-opacity", 1);

                            const nodeExit = node.exit().transition()
                                .duration(duration)
                                .attr("transform", 'translate(' + source.y + ',' + source.x + ')')
                                .remove();

                            nodeExit.select("circle").attr("r", 1e-6);
                            nodeExit.select("text").style("fill-opacity", 1e-6);

                            const link = g.selectAll("path.link")
                                .data(links, d => d.target.id);

                            const linkEnter = link.enter().insert("path", "g")
                                .attr("class", "link")
                                .attr("d", d => {
                                    const o = { x: source.x0, y: source.y0 };
                                    return d3.linkHorizontal()({ source: o, target: o });
                                })
                                .style("stroke", d => 'var(--color-level-' + (d.source.depth % 5) + ')');

                            link.merge(linkEnter).transition()
                                .duration(duration)
                                .attr("d", d3.linkHorizontal().x(d => d.y).y(d => d.x));

                            link.exit().transition()
                                .duration(duration)
                                .attr("d", d => {
                                    const o = { x: source.x, y: source.y };
                                    return d3.linkHorizontal()({ source: o, target: o });
                                })
                                .remove();

                            nodes.forEach(d => {
                                d.x0 = d.x;
                                d.y0 = d.y;
                            });
                        }
                    } else if (displayStyle === 'no-line') {
                        const rootElement = document.createElement('div');
                        rootElement.className = 'mindmap-no-line-root';
                        mindMapOutput.appendChild(rootElement);

                        rootElement.style.maxHeight = 'none'; 
                        rootElement.style.overflow = 'visible'; 
                        rootElement.style.width = '100%'; 
                        rootElement.style.boxSizing = 'border-box';

                        function createNodeRecursive(nodeData, depth) {
                            const nodeWrapper = document.createElement('div');
                            nodeWrapper.className = \`node-item-wrapper\`;

                            const nodeContentDiv = document.createElement('div');
                            nodeContentDiv.className = \`node-content-display node-level-\${depth % 5}\`;
                            nodeContentDiv.style.marginLeft = \`\${depth * 20}px\`;

                            let toggleIcon = null;
                            if (nodeData.children && nodeData.children.length > 0) {
                                toggleIcon = document.createElement('span');
                                toggleIcon.className = 'expand-toggle font-bold';
                                toggleIcon.textContent = '▶';
                                nodeContentDiv.appendChild(toggleIcon);
                            } else {
                                const placeholderToggle = document.createElement('span');
                                placeholderToggle.className = 'expand-toggle';
                                placeholderToggle.style.visibility = 'hidden';
                                nodeContentDiv.appendChild(placeholderToggle);
                            }

                            const horizontalLine = document.createElement('span');
                            horizontalLine.className = 'horizontal-line';
                            nodeContentDiv.appendChild(horizontalLine);

                            const nodeTextSpan = document.createElement('span');
                            nodeTextSpan.className = 'node-text';
                            nodeTextSpan.textContent = nodeData.node;
                            nodeContentDiv.appendChild(nodeTextSpan);

                            nodeWrapper.appendChild(nodeContentDiv);

                            if (nodeData.children && nodeData.children.length > 0) {
                                const childrenContainer = document.createElement('div');
                                childrenContainer.className = 'children-container collapsed';
                                nodeWrapper.appendChild(childrenContainer);

                                nodeContentDiv.onclick = (event) => {
                                    event.stopPropagation();
                                    const isCollapsed = childrenContainer.classList.contains('collapsed');
                                    if (isCollapsed) {
                                        childrenContainer.classList.remove('collapsed');
                                        childrenContainer.classList.add('expanded');
                                        if (toggleIcon) toggleIcon.textContent = '▼';
                                    } else {
                                        childrenContainer.classList.remove('expanded');
                                        childrenContainer.classList.add('collapsed');
                                        if (toggleIcon) toggleIcon.textContent = '▶';
                                    }
                                };

                                nodeData.children.forEach(child => {
                                    childrenContainer.appendChild(createNodeRecursive(child, depth + 1));
                                });
                            }
                            return nodeWrapper;
                        }
                        rootElement.appendChild(createNodeRecursive(d3FormattedData, 0));
                    }
                }
            `;

            const htmlContent = `
                <!DOCTYPE html>
                <html lang="zh-TW">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>動態心智圖</title>
                    <script src="https://d3js.org/d3.v7.min.js"><\/script>
                    <style>
                        html, body {
                            height: 100%;
                            margin: 0;
                            padding: 0;
                        }
                        body {
                            overflow-y: auto;
                            background: #f0f2f5;
                            padding: 2rem;
                            font-family: 'Inter', sans-serif;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: flex-start;
                            min-height: 100vh;
                        }
                        :root {
                            --primary: #6366f1;
                            --primary-dark: #4f46e5;
                            --secondary: #8b5cf6;
                            --accent: #0ea5e9;
                            --success: #10b981;
                            --warning: #f59e0b;
                            --danger: #ef4444;
                            --light-bg: #f8fafc;
                            --dark-bg: #0f172a;
                            --text-primary: #1e293b;
                            --text-secondary: #475569;

                            --color-level-0: #6366f1;
                            --color-level-1: #8b5cf6;
                            --color-level-2: #0ea5e9;
                            --color-level-3: #10b981;
                            --color-level-4: #f59e0b;
                        }

                        #mindMapDownloadContainer {
                            width: 1000px;
                            max-width: 95vw;
                            margin: 0 auto;
                            background-color: var(--light-bg);
                            border: 1px solid #e2e8f0;
                            border-radius: 0.75rem;
                            padding: 0;
                            overflow: auto; 
                            min-height: 500px;
                            max-height: 80vh;
                            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
                            box-sizing: border-box;
                        }
                        .node circle {
                            stroke-width: 2.5px;
                            cursor: pointer;
                        }
                        .node text {
                            font-family: 'Inter', sans-serif;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: pointer;
                        }
                        .link {
                            fill: none;
                            stroke: #cbd5e1;
                            stroke-width: 2px;
                        }

                        .mindmap-no-line-root {
                            padding: 1rem;
                            width: 100%;
                            box-sizing: border-box;
                            max-height: none;
                            overflow: visible;
                        }
                        .node-item-wrapper {
                            display: block;
                            margin-bottom: 0.75rem;
                        }
                        .node-content-display {
                            padding: 0.75rem 1rem;
                            border-radius: 0.5rem;
                            font-weight: 500;
                            transition: background-color 0.2s ease, box-shadow 0.2s ease;
                            align-items: center;
                            display: flex;
                            position: relative;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.08);
                            color: var(--text-primary);
                            cursor: pointer;
                            min-height: 40px;
                        }
                        .node-content-display:hover {
                            filter: brightness(1.03);
                            box-shadow: 0 4px 10px rgba(0,0,0,0.12);
                        }
                        .horizontal-line {
                            display: block;
                            width: 20px;
                            height: 2px;
                            background-color: var(--primary);
                            margin-right: 8px;
                            border-radius: 1px;
                            flex-shrink: 0;
                        }
                        .node-text {
                            flex-grow: 1;
                            line-height: 1.3;
                        }
                        .expand-toggle {
                            cursor: pointer;
                            font-size: 1.2em;
                            padding-right: 0.5rem;
                            transition: transform 0.2s ease-in-out;
                            color: var(--primary);
                            flex-shrink: 0;
                        }
                        .children-container {
                            padding-left: 1.5rem;
                            overflow: hidden;
                            max-height: 0;
                            transition: max-height 0.3s ease-out;
                        }
                        .children-container.collapsed {
                            max-height: 0 !important;
                            overflow: hidden !important;
                        }
                        .children-container.expanded {
                            max-height: 1000px !important;
                            overflow: visible !important;
                        }
                        .node-level-0 { background: linear-gradient(to right, var(--color-level-0), var(--color-level-1)); color: white; font-weight: bold; font-size: 1.1rem; border-radius: 0.75rem; padding: 1rem 1.5rem; }
                        .node-level-0 .horizontal-line { display: none; }
                        .node-level-0 .expand-toggle { color: white; }
                        .node-level-1 { background-color: #f0f4ff; color: var(--text-primary); border: 1px solid #e0e7ff; }
                        .node-level-1 .horizontal-line { background-color: var(--color-level-1); }
                        .node-level-1 .expand-toggle { color: var(--color-level-1); }
                        .node-level-2 { background-color: #e6eaff; color: var(--text-primary); border: 1px solid #d0d7ff; }
                        .node-level-2 .horizontal-line { background-color: var(--color-level-2); }
                        .node-level-2 .expand-toggle { color: var(--color-level-2); }
                        .node-level-3 { background-color: #dce0ff; color: var(--text-primary); border: 1px solid #c0c7ff; }
                        .node-level-3 .horizontal-line { background-color: var(--color-level-3); }
                        .node-level-3 .expand-toggle { color: var(--color-level-3); }
                        .node-level-4 { background-color: #d2d6ff; color: var(--text-primary); border: 1px solid #b0b7ff; }
                        .node-level-4 .horizontal-line { background-color: var(--color-level-4); }
                        .node-level-4 .expand-toggle { color: var(--color-level-4); }
                        .mindmap-no-line-root > .node-item-wrapper:first-child > .node-content-display > .horizontal-line { display: none; }
                        svg { display: block; }
                    </style>
                </head>
                <body>
                    <h1 style="text-align:center; color: #1e293b; margin-bottom: 1.5rem;">動態心智圖</h1>
                    <div id="mindMapDownloadContainer"></div>
                    <script>
                        document.addEventListener('DOMContentLoaded', () => {
                            const mindMapData = ${JSON.stringify(mindMapJsonData)};
                            const displayStyle = '${currentMindMapStyle}';
                            const renderFunction = ${scriptFunctionString};
                            const style = document.createElement('style');
                            style.innerHTML = \`.children-container.expanded { max-height: \${document.body.scrollHeight}px !important; }\`;
                            document.head.appendChild(style);
                            renderFunction(mindMapData, d3, displayStyle);
                        });
                    <\/script>
                </body>
                </html>
            `;

            const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '動態心智圖.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showFloatingInfo('動態 HTML 已成功下載！', 'success');
        }


        // 顯示浮動信息
        function showFloatingInfo(message, type = 'info') {
            const existingInfo = document.querySelector('.floating-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            const colors = {
                info: { bg: '#dbeafe', text: '#1d4ed8', icon: 'ℹ️' },
                success: { bg: '#dcfce7', text: '#166534', icon: '✅' },
                error: { bg: '#fee2e2', text: '#b91c1c', icon: '❌' },
                warning: { bg: '#fef3c7', text: '#92400e', icon: '⚠️' }
            };
            
            const color = colors[type] || colors.info;
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'floating-info';
            infoDiv.style.backgroundColor = color.bg;
            infoDiv.style.color = color.text;
            
            infoDiv.innerHTML = `
                <button class="close-btn">×</button>
                <h3>${color.icon} ${message}</h3>
            `;
            
            document.body.appendChild(infoDiv);
            
            infoDiv.querySelector('.close-btn').addEventListener('click', () => {
                infoDiv.remove();
            });
            
            setTimeout(() => {
                if (document.body.contains(infoDiv)) {
                    infoDiv.remove();
                }
            }, 5000);
        }
        
        function formatTextForDisplay(text) {
            const externalInfoRegex = /<div class='external-info-box'>[\s\S]*?<\/div>/g;
            const externalInfoMatches = text.match(externalInfoRegex) || [];
            const placeholder = '___EXTERNAL_INFO_PLACEHOLDER___';
            
            let processedText = text.replace(externalInfoRegex, placeholder);

            processedText = processedText
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n/g, '<br>');

            externalInfoMatches.forEach(match => {
                processedText = processedText.replace(placeholder, match);
            });

            return processedText;
        }

        async function handleAnalysis(chapterContent) {
            currentAnalysisContext = {
                chapterContent: chapterContent,
                originalInput: textInput.value.trim() || "無原始文字輸入，內容來自檔案。",
                analysis: '',
                history: []
            };
            
            analysisModalTitle.textContent = `分析: ${chapterContent}`;
            analysisResult.innerHTML = '<div class="flex justify-center items-center h-full"><div class="loading-spinner" style="border-top-color: var(--primary);"></div><p class="ml-4">正在生成分析報告...</p></div>';
            qaChatHistory.innerHTML = '';
            qaInput.value = '';
            analysisModal.classList.add('active');

            let finalApiKey = "";
            if (typeof __app_id === 'undefined' && !userProvidedApiKey) {
                 analysisResult.innerHTML = '<p class="text-red-500">錯誤：請先設定您的 Gemini API Key。</p>';
                 return;
            }
            finalApiKey = userProvidedApiKey;

            const analysisPrompt = `
                你是一位頂級的行業分析師和研究員。請針對以下「指定章節」，並參考「完整原始資料」作為上下文，進行一次深入、詳細的綜合分析。

                **分析要求：**
                1.  **整合外部知識**：你的分析**必須**超越原始資料，模擬你已經搜尋並整合了來自網路的相關外部資訊、研究報告和行業趨勢。
                2.  **深入解析**：不僅僅是總結，要提供深刻的見解、潛在的影響、相關的案例研究（如果適用）以及未來的發展預測。
                3.  **結構化輸出**：使用標題、列表和粗體字來組織你的分析，使其清晰易讀。
                4.  **保持客觀**：在引用外部資訊時，可以註明「根據行業普遍看法」或「研究顯示」等。

                ---
                **【完整原始資料】**
                ${currentAnalysisContext.originalInput}
                ---
                **【指定章節】**
                ${chapterContent}
                ---

                請開始你的綜合分析報告：
            `;
            
            const payload = { contents: [{ role: "user", parts: [{ text: analysisPrompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${finalApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API 請求失敗，狀態碼: ${response.status}`);
                
                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const analysisText = result.candidates[0].content.parts[0].text;
                    currentAnalysisContext.analysis = analysisText;
                    analysisResult.innerHTML = formatTextForDisplay(analysisText);
                } else {
                    throw new Error('API 未返回有效的分析內容。');
                }
            } catch (error) {
                console.error('分析生成錯誤:', error);
                analysisResult.innerHTML = `<p class="text-red-500">分析生成失敗: ${error.message}</p>`;
            }
        }

        async function handleQaAsk() {
            const question = qaInput.value.trim();
            if (!question) return;

            addToChatHistory('user', question);
            qaInput.value = '';
            qaLoadingSpinner.classList.remove('hidden');
            qaAskBtn.disabled = true;

            let finalApiKey = "";
            if (typeof __app_id === 'undefined' && !userProvidedApiKey) {
                addToChatHistory('ai', '錯誤：請先設定您的 Gemini API Key。');
                qaLoadingSpinner.classList.add('hidden');
                qaAskBtn.disabled = false;
                return;
            }
            finalApiKey = userProvidedApiKey;

            const searchQuery = `${currentAnalysisContext.chapterContent} ${question}`;
            const simulatedSearchResult = {
                title: `關於 "${question}" 的模擬研究`,
                snippet: "這是一段從模擬搜尋結果中提取的摘要，提供了關於該問題的額外背景資訊，例如市場趨勢、技術細節或專家觀點。",
                url: `https://www.google.com/search?q=${encodeURIComponent(searchQuery)}`
            };

            const qaPrompt = `
                你是一個針對特定章節內容的問答AI。請根據使用者提供的「原始資料」、「指定章節」、「AI的初始分析報告」、「對話歷史」以及「模擬的外部搜尋資訊」，回答使用者提出的「新問題」。

                **回答要求：**
                1.  **優先使用內部資料**：首先根據「原始資料」、「指定章節」、「初始分析」和「對話歷史」進行回答。
                2.  **補充外部資訊**：如果內部資料不足以完整回答，或「模擬的外部搜尋資訊」能提供有價值的補充時，才使用它。
                3.  **嚴格的格式要求**：
                    * 你的主要回答應該是直接的、簡潔的。
                    * 如果你的回答中**引用了**「模擬的外部搜尋資訊」，你**必須**在主要回答結束後，另起一段，使用以下**一字不差**的HTML格式來呈現外部資訊和來源：
                    \`\`\`html
<div class='external-info-box'><strong>外部資訊補充:</strong><p>[此處是基於外部資料的回答內容]</p><p class='source'>來源: <a href='${simulatedSearchResult.url}' target='_blank'>${simulatedSearchResult.title}</a></p></div>
                    \`\`\`
                4.  **不要發明**：如果所有資訊都不足以回答，請誠實地告知使用者「根據目前所擁有的資料，我無法回答這個問題。」

                ---
                **【完整原始資料】**
                ${currentAnalysisContext.originalInput}
                ---
                **【指定章節】**
                ${currentAnalysisContext.chapterContent}
                ---
                **【AI的初始分析報告】**
                ${currentAnalysisContext.analysis}
                ---
                **【對話歷史】**
                ${currentAnalysisContext.history.map(h => `${h.role === 'user' ? '使用者' : 'AI'}: ${h.content}`).join('\n')}
                ---
                **【模擬的外部搜尋資訊】**
                - 標題: ${simulatedSearchResult.title}
                - 摘要: ${simulatedSearchResult.snippet}
                - 網址: ${simulatedSearchResult.url}
                ---
                **【使用者的新問題】**
                ${question}
                ---

                請嚴格按照上述規則回答：
            `;

            const payload = { contents: [{ role: "user", parts: [{ text: qaPrompt }] }] };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${finalApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) throw new Error(`API 請求失敗，狀態碼: ${response.status}`);

                const result = await response.json();
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const answerText = result.candidates[0].content.parts[0].text;
                    addToChatHistory('ai', answerText);
                } else {
                    throw new Error('API 未返回有效的回答內容。');
                }
            } catch (error) {
                console.error('問答錯誤:', error);
                addToChatHistory('ai', `抱歉，回答時發生錯誤: ${error.message}`);
            } finally {
                qaLoadingSpinner.classList.add('hidden');
                qaAskBtn.disabled = false;
            }
        }

        function addToChatHistory(role, text) {
            currentAnalysisContext.history.push({ role: role, content: text });
            
            const bubble = document.createElement('div');
            bubble.classList.add('qa-bubble', role);
            bubble.innerHTML = formatTextForDisplay(text);
            
            qaChatHistory.appendChild(bubble);
            qaChatHistory.scrollTop = qaChatHistory.scrollHeight;
        }
        
        /**
         * **修改**: 處理語音導讀，使用優化後的腳本
         */
        function handleReadAloud() {
            if (isReading) {
                wasManuallyStopped = true;
                speechSynthesis.cancel();
                return;
            }
            
            // 直接使用優化後的導讀稿
            const textToRead = optimizedNarrationScript;

            if (!textToRead) {
                showFloatingInfo('沒有可導讀的摘要內容', 'error');
                return;
            }

            wasManuallyStopped = false;
            const utterance = new SpeechSynthesisUtterance(textToRead);
            utterance.lang = 'zh-TW';
            utterance.rate = 1;
            utterance.pitch = 1;

            utterance.onstart = () => {
                isReading = true;
                readAloudBtnText.textContent = '停止導讀';
            };

            utterance.onend = () => {
                if (wasManuallyStopped) {
                    showFloatingInfo('語音導讀已停止', 'info');
                }
                isReading = false;
                readAloudBtnText.textContent = '語音導讀';
                wasManuallyStopped = false;
            };

            utterance.onerror = (event) => {
                if (!wasManuallyStopped) {
                    console.error('語音合成錯誤:', event.error);
                    showFloatingInfo(`語音導讀時發生錯誤: ${event.error}`, 'error');
                }
                isReading = false;
                readAloudBtnText.textContent = '語音導讀';
                wasManuallyStopped = false;
            };
            
            speechSynthesis.speak(utterance);
        }
        
        /**
         * **修改**: 處理摘要文字檔(TXT)下載，使用優化後的腳本
         */
        function handleDownloadSummaryTxt() {
            // 直接使用優化後的導讀稿
            const textContent = optimizedNarrationScript;

            if (!textContent) {
                showFloatingInfo('沒有可下載的摘要內容', 'error');
                return;
            }

            try {
                const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = '優化導讀稿.txt'; // 更新檔名以反映內容
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showFloatingInfo('TXT 檔案已成功下載！', 'success');
            } catch (error) {
                console.error('TXT 下載失敗:', error);
                showFloatingInfo(`TXT 下載失敗: ${error.message}`, 'error');
            }
        }

        // 事件監聽器
        summaryOutput.addEventListener('click', (e) => {
            if (e.target && e.target.classList.contains('analyze-btn')) {
                const chapterContent = e.target.getAttribute('data-content');
                handleAnalysis(chapterContent);
            }
        });

        endAnalysisBtn.addEventListener('click', () => {
            analysisModal.classList.remove('active');
        });

        qaAskBtn.addEventListener('click', handleQaAsk);
        qaInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                handleQaAsk();
            }
        });

        // 初始顯示使用指南
        setTimeout(() => {
            showFloatingInfo('歡迎使用！請輸入內容或上傳文件開始。', 'info');
        }, 1500);

    </script>
</body>
</html>
